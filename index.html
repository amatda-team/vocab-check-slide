<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Signal Voca (Slide)</title>

  <!-- Shoelace (CDN) -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.15.0/cdn/themes/light.css">
  <script type="module" src="https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.15.0/cdn/shoelace.js"></script>

  <style>
    :root{
      --app-max: 520px;

      /* ✅ Boot motion controls (여기만 조절하면 됨) */
      --boot-hold-ms: 600ms;     /* x: 중앙 홀드 */
      --boot-move-ms: 3000ms;    /* y: 이동 */
      --boot-ease: cubic-bezier(.2,.9,.25,1);

      /* ✅ Yellow(주황) 의미 토글 연출 */
      --yellow-word-hold-ms: 120ms;     /* 클릭 후 살짝 텀 */
      --yellow-swap-ms: 220ms;          /* word ↔ meaning 텍스트 페이드 */
      --yellow-width-ms: 320ms;         /* pill width 늘고 줄기 */
      --yellow-keep-meaning-ms: 520ms;  /* meaning 보이는 시간 */

      /* Theme */
      --bg0: #070a10;
      --bg1: #0b0f14;

      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.58);

      --track: rgba(255,255,255,.06);
      --line: rgba(255,255,255,.10);

      --radius: 18px;
      --pill-radius: 999px;

      --track-h: 72px;
      --pill-h: 44px;
      --pill-w: 140px;

      --pad: 12px;
      --lr-pad: 12px;

      /* Signal colors */
      --sig-red:   255,  90,  90;
      --sig-yellow:255, 176,  64; /* 주황 */
      --sig-green:  80, 220, 140;
    }

    *{ box-sizing: border-box; }

    /* ✅ overscroll white flash 방지 */
    html{ background: var(--bg0); }
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Apple SD Gothic Neo", "Noto Sans KR", Arial, "Helvetica Neue", sans-serif;
      color: var(--text);
      min-height: 100svh;
      background: transparent;
    }
    body::before{
      content:"";
      position: fixed;
      inset: 0;
      z-index: -1;
      pointer-events: none;
      background:
        radial-gradient(1200px 800px at 50% -200px, rgba(80,130,255,.18), transparent 60%),
        linear-gradient(180deg, var(--bg0), var(--bg1) 40%, var(--bg0));
      transform: translateZ(0);
    }

    /* iOS: prevent custom element flash */
    sl-dialog:not(:defined){ display:none !important; }
    sl-alert:not(:defined){ display:none !important; }
    sl-button:not(:defined){ visibility:hidden; }

    .app{
      max-width: var(--app-max);
      margin: 0 auto;
      padding: 18px var(--pad) 120px;
    }

    .header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 12px;
      margin: 6px 0 12px;
    }
    .header h1{
      margin: 0;
      font-size: 28px;
      letter-spacing: -.4px;
      font-weight: 900;
      line-height: 1.1;
    }

    .toast-wrap{
      position: sticky;
      top: 10px;
      z-index: 999;
      padding: 0 var(--pad);
    }
    .toast-wrap sl-alert{
      max-width: var(--app-max);
      margin: 0 auto;
      border-radius: 14px;
    }

    .list{
      display:flex;
      flex-direction:column;
      gap: 14px;
      margin-top: 12px;
    }

    .empty{
      margin-top: 18px;
      padding: 18px;
      border: 1px dashed rgba(255,255,255,.16);
      border-radius: 16px;
      color: var(--muted);
      text-align:center;
      line-height: 1.6;
    }
    .empty b{ color: var(--text); }

    /* Track */
    .track{
      position: relative;
      height: var(--track-h);
      border-radius: var(--radius);
      background: var(--track);
      border: 1px solid var(--line);
      overflow: hidden;
      -webkit-tap-highlight-color: transparent;

      transition: opacity .16s ease, transform .16s ease;
    }
    .track.preboot{
      opacity: 0;
      transform: translateY(2px);
    }

    /* tint continuous */
    .tint{
      position:absolute;
      inset:0;
      opacity: 0;
      pointer-events:none;
      transition: opacity .10s linear;
    }
    .tint.left{
      background: radial-gradient(600px 240px at 0% 55%, rgba(var(--sig-red), .22), transparent 62%);
    }
    .tint.right{
      background: radial-gradient(600px 240px at 100% 55%, rgba(var(--sig-green), .22), transparent 62%);
    }

    /* ✅ Signal lights (replace labels) */
    .signals{
      position:absolute;
      inset:0;
      pointer-events:none;
      z-index: 1;
    }

    .sigLR{
      position:absolute;
      left: var(--lr-pad);
      right: var(--lr-pad);
      top: 50%;
      transform: translateY(-50%);
      display:flex;
      justify-content:space-between;
      align-items:center;
      opacity: 1;
      transition: opacity .14s ease;
    }

    .sigDot{
      width: 12px;
      height: 12px;
      border-radius: 999px;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.10);
      box-shadow: 0 0 0 rgba(255,255,255,0);
      opacity: .9;
      transform: translateZ(0);
    }
    .sigDot.red{
      background: rgba(var(--sig-red), .20);
      border-color: rgba(var(--sig-red), .35);
      box-shadow:
        0 0 18px rgba(var(--sig-red), .35),
        0 0 44px rgba(var(--sig-red), .14);
    }
    .sigDot.green{
      background: rgba(var(--sig-green), .20);
      border-color: rgba(var(--sig-green), .35);
      box-shadow:
        0 0 18px rgba(var(--sig-green), .35),
        0 0 44px rgba(var(--sig-green), .14);
    }

    /* yellow hint under pill (z축: pill 아래, meaning 위/아래 상관없게) */
    .sigYellowUnder{
      position:absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: 54px;
      height: 22px;
      border-radius: 999px;
      background: radial-gradient(30px 18px at 50% 50%, rgba(var(--sig-yellow), .36), rgba(var(--sig-yellow), .08) 60%, transparent 72%);
      filter: blur(.2px);
      opacity: .75;
      transition: opacity .16s ease, transform .16s ease;
      z-index: 1;
      pointer-events:none;
    }

    /* meaning slots */
    .meaning-slot{
      position:absolute;
      top: 50%;
      transform: translateY(-50%);
      width: 46%;
      padding: 0 var(--lr-pad);
      pointer-events:none;

      opacity: 0;
      transition: opacity .10s linear, transform .16s ease;

      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      font-size: 14px;
      color: rgba(255,255,255,.78);
      z-index: 2;
    }
    .meaning-left{
      left: 0;
      text-align:left;
    }
    .meaning-right{
      right: 0;
      text-align:right;
    }
    .meaning-slot.small{ font-size: 13px; }
    .meaning-slot.smaller{ font-size: 12px; }

    /* click zones */
    .zone{
      position:absolute;
      top:0; bottom:0;
      z-index: 3;
      background: transparent;
    }
    .zone.left{ left:0; width:34%; }
    .zone.center{ left:33%; width:34%; }
    .zone.right{ right:0; width:34%; }

    /* pill */
    .pill{
      position:absolute;
      top: 50%;
      transform: translateY(-50%) translateX(0px);
      left: 10px;
      height: var(--pill-h);
      width: var(--pill-w);
      border-radius: var(--pill-radius);

      background: rgba(230,235,245,.22);
      border: 1px solid rgba(255,255,255,.14);

      display:flex;
      align-items:center;
      justify-content:center;
      padding: 0 14px;

      font-weight: 900;
      letter-spacing: -.2px;
      color: rgba(255,255,255,.92);

      user-select:none;
      -webkit-user-select:none;
      touch-action: pan-y;

      will-change: transform, background, border-color, width;
      transition:
        transform .18s cubic-bezier(.2,.9,.25,1),
        background .10s linear,
        border-color .10s linear,
        width var(--yellow-width-ms) ease;

      z-index: 4;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .pill .pillText{
      display:inline-block;
      will-change: opacity, transform;
      transition: opacity var(--yellow-swap-ms) ease, transform var(--yellow-swap-ms) ease;
    }
    .pill.swap-out .pillText{
      opacity: 0;
      transform: translateY(1px);
    }
    .pill.swap-in .pillText{
      opacity: 1;
      transform: translateY(0);
    }

    .pill.dragging{
      transition:none !important;
      touch-action: none;
    }

    .pill.booting{ transition: none !important; }

    /* State classes */
    .track.is-unknown .sigLR{ opacity: 1; }
    .track.is-red .sigLR,
    .track.is-green .sigLR,
    .track.is-yellow .sigLR{ opacity: 0; }

    .track.is-unknown .sigYellowUnder{ opacity: .75; }
    .track.is-red .sigYellowUnder,
    .track.is-green .sigYellowUnder,
    .track.is-yellow .sigYellowUnder{ opacity: 0; }

    /* In yellow: meaning slots hidden (yellow는 pill 안에서 의미 표시) */
    .track.is-yellow .meaning-slot{ opacity: 0 !important; transform: translateY(-50%) translateX(0) !important; }

    /* Footer */
    .footer{
      position: fixed;
      left:0; right:0; bottom:0;
      padding: 12px var(--pad) calc(12px + env(safe-area-inset-bottom));
      background: linear-gradient(180deg, transparent, rgba(0,0,0,.35) 25%, rgba(0,0,0,.55));
      backdrop-filter: blur(10px);
      z-index: 50;

      opacity: 0;
      transform: translateY(8px);
      pointer-events:none;
      transition: opacity .18s ease, transform .18s ease;
    }
    html.ready .footer{
      opacity: 1;
      transform: translateY(0);
      pointer-events:auto;
    }
    .footer-inner{
      max-width: var(--app-max);
      margin: 0 auto;
    }

    /* Shoelace tweaks */
    sl-dialog::part(panel){
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(20,24,32,.96);
      color: var(--text);
    }
    sl-dialog::part(title){
      font-weight: 900;
      letter-spacing: -.2px;
    }
    sl-button::part(base){ border-radius: 14px; }

    /* Charge modal simplified */
    .charge-msg{
      font-size: 14px;
      color: rgba(255,255,255,.86);
      line-height: 1.5;
      margin-bottom: 10px;
    }
    .charge-remain{
      font-size: 12px;
      color: var(--muted);
      margin-bottom: 14px;
    }
    .btn-row{
      display:flex;
      gap: 10px;
    }
    .btn-row sl-button{ flex: 1 1 0; }
    .btn-row sl-button::part(base){ width: 100%; }

    /* Hidden measurer */
    .measure{
      position: absolute;
      left:-9999px; top:-9999px;
      visibility:hidden;
      white-space:nowrap;
      font-weight: 900;
      letter-spacing: -.2px;
      font-family: inherit;
      font-size: 16px;
      padding: 0 14px;
    }
  </style>
</head>

<body>
  <div class="toast-wrap" aria-live="polite" aria-atomic="true">
    <sl-alert id="toast" variant="primary" duration="2200" closable>
      <sl-icon slot="icon" name="info-circle"></sl-icon>
      <span id="toastText">안내</span>
    </sl-alert>
  </div>

  <main class="app">
    <div class="header">
      <h1>오늘의 단어</h1>
      <sl-button id="btnCharge" variant="primary">충전하기</sl-button>
    </div>

    <div id="emptyState" class="empty" style="display:none;">
      아직 오늘의 단어가 <b>0개</b>예요.<br>
      상단의 <b>충전하기</b>로 10개씩 추가해 주세요.
    </div>

    <div id="list" class="list"></div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      <sl-button id="ctaSubmit" variant="neutral" outline disabled style="width:100%;">제출하기 (Phase 2~)</sl-button>
    </div>
  </footer>

  <!-- Charge dialog -->
  <sl-dialog id="dlgCharge" label="충전하기">
    <div class="charge-msg">한 번에 10개씩 충전이 가능해요</div>
    <div class="charge-remain">오늘 남은 횟수 <b id="remainText">3/3</b></div>
    <div class="btn-row">
      <sl-button id="dlgChargeDo" variant="primary">충전하기</sl-button>
      <sl-button id="dlgChargeClose" variant="default" outline>닫기</sl-button>
    </div>
  </sl-dialog>

  <!-- measurer -->
  <span id="measure" class="measure"></span>

<script>
/* =========================
   Storage / State
========================= */
const LS_KEY = "vocab_slide_v1_signal";
const todayKey = (() => {
  const d = new Date();
  const y = d.getFullYear();
  const m = String(d.getMonth() + 1).padStart(2, "0");
  const day = String(d.getDate()).padStart(2, "0");
  return `${y}-${m}-${day}`;
})();

/**
 * status: "unknown" | "red" | "yellow" | "green"
 * - red   : 왼쪽 확정 (기존 dont)
 * - green : 오른쪽 확정 (기존 know)
 * - yellow: 중앙 확정(주황), 의미 토글은 pill 내부에서
 */
function loadState() {
  try {
    const raw = localStorage.getItem(LS_KEY);
    if (!raw) return { day: todayKey, chargeUsed: 0, words: [] };
    const s = JSON.parse(raw);
    if (s.day !== todayKey) return { day: todayKey, chargeUsed: 0, words: [] };
    return {
      day: s.day || todayKey,
      chargeUsed: Number(s.chargeUsed || 0),
      words: Array.isArray(s.words) ? s.words : []
    };
  } catch (e) {
    return { day: todayKey, chargeUsed: 0, words: [] };
  }
}

function saveState(state) {
  localStorage.setItem(LS_KEY, JSON.stringify(state));
}

function makeDummyWords(n) {
  const pool = [
    ["abandon", "버리다, 포기하다"],
    ["accurate", "정확한"],
    ["benevolent", "자비로운, 선의의"],
    ["consequence", "결과, 영향"],
    ["diligent", "성실한"],
    ["elaborate", "정교한, 상세히 설명하다"],
    ["friction", "마찰, 충돌"],
    ["gratitude", "감사"],
    ["hesitate", "망설이다"],
    ["inevitable", "피할 수 없는"]
  ];
  const out = [];
  const base = Date.now().toString(36);
  for (let i = 0; i < n; i++) {
    const pick = pool[Math.floor(Math.random() * pool.length)];
    out.push({
      id: `${base}-${i}-${Math.random().toString(16).slice(2, 8)}`,
      word: pick[0],
      meaning: pick[1],
      status: "unknown"
    });
  }
  return out;
}

/* =========================
   UI refs
========================= */
const toast = document.getElementById("toast");
const toastText = document.getElementById("toastText");

const btnCharge = document.getElementById("btnCharge");
const dlgCharge = document.getElementById("dlgCharge");
const dlgChargeDo = document.getElementById("dlgChargeDo");
const dlgChargeClose = document.getElementById("dlgChargeClose");
const remainText = document.getElementById("remainText");

const listEl = document.getElementById("list");
const emptyState = document.getElementById("emptyState");

const measureEl = document.getElementById("measure");

function showToast(msg) {
  toastText.textContent = msg;
  toast.toast();
}

function escapeHtml(s) {
  return String(s)
    .replaceAll("&", "&amp;")
    .replaceAll("<", "&lt;")
    .replaceAll(">", "&gt;")
    .replaceAll('"', "&quot;")
    .replaceAll("'", "&#039;");
}

/* =========================
   Helpers
========================= */
function lerp(a, b, t) { return a + (b - a) * t; }
function clamp01(x) { return Math.max(0, Math.min(1, x)); }
function smoothstep(t) { t = clamp01(t); return t * t * (3 - 2 * t); }
function easeInOutCubic(t){
  t = clamp01(t);
  return t < 0.5 ? 4*t*t*t : 1 - Math.pow(-2*t + 2, 3) / 2;
}
function parseMs(str, fallback) {
  const s = String(str || "").trim();
  if (!s) return fallback;
  if (s.endsWith("ms")) return parseFloat(s);
  if (s.endsWith("s")) return parseFloat(s) * 1000;
  const n = parseFloat(s);
  return Number.isFinite(n) ? n : fallback;
}
function getVarMs(name, fallback) {
  const v = getComputedStyle(document.documentElement).getPropertyValue(name);
  return parseMs(v, fallback);
}

/* =========================
   Colors (pill) — neutral ↔ red/green + yellow
========================= */
const COL_NEUTRAL_BG = [230, 235, 245, 0.22];
const COL_NEUTRAL_BD = [255, 255, 255, 0.14];

const COL_RED_BG     = [255,  90,  90, 0.30];
const COL_RED_BD     = [255,  90,  90, 0.32];

const COL_GREEN_BG   = [ 80, 220, 140, 0.30];
const COL_GREEN_BD   = [ 80, 220, 140, 0.32];

const COL_YELLOW_BG  = [255, 176,  64, 0.30];
const COL_YELLOW_BD  = [255, 176,  64, 0.34];

function mixRGBA(c1, c2, t) {
  return [
    Math.round(lerp(c1[0], c2[0], t)),
    Math.round(lerp(c1[1], c2[1], t)),
    Math.round(lerp(c1[2], c2[2], t)),
    lerp(c1[3], c2[3], t)
  ];
}
function rgbaStr(c) { return `rgba(${c[0]},${c[1]},${c[2]},${c[3]})`; }

/* =========================
   Track builder
========================= */
function buildTrackRow(wordObj, index, state) {
  const el = document.createElement("div");
  el.className = "track is-unknown preboot";
  el.dataset.index = String(index);

  el.innerHTML = `
    <div class="tint left"></div>
    <div class="tint right"></div>

    <div class="signals">
      <div class="sigLR">
        <div class="sigDot red" aria-hidden="true"></div>
        <div class="sigDot green" aria-hidden="true"></div>
      </div>
      <div class="sigYellowUnder" aria-hidden="true"></div>
    </div>

    <div class="meaning-slot meaning-left"></div>
    <div class="meaning-slot meaning-right"></div>

    <div class="zone left" aria-label="RED(몰라요)"></div>
    <div class="zone center" aria-label="가운데(UNKNOWN)"></div>
    <div class="zone right" aria-label="GREEN(알아요)"></div>

    <div class="pill" role="button" aria-label="단어 카드">
      <span class="pillText">${escapeHtml(wordObj.word)}</span>
    </div>
  `;

  const tintL  = el.querySelector(".tint.left");
  const tintR  = el.querySelector(".tint.right");
  const pill   = el.querySelector(".pill");
  const pillText = el.querySelector(".pillText");
  const meanL  = el.querySelector(".meaning-left");
  const meanR  = el.querySelector(".meaning-right");
  const sigLR  = el.querySelector(".sigLR");
  const sigY   = el.querySelector(".sigYellowUnder");
  const zoneL  = el.querySelector(".zone.left");
  const zoneC  = el.querySelector(".zone.center");
  const zoneR  = el.querySelector(".zone.right");

  meanL.textContent = wordObj.meaning || "";
  meanR.textContent = wordObj.meaning || "";
  applyMeaningSizing(meanL);
  applyMeaningSizing(meanR);

  // Geometry
  let minX = 0, maxX = 0, curX = 0;

  // 중앙 데드존
  const TH_LEFT  = 0.40;
  const TH_RIGHT = 0.60;

  // Intent-based drag (scroll vs drag)
  let pending = false;
  let intent = null;   // "drag" | "scroll" | null
  let pid = null;
  let downX = 0, downY = 0;
  let startClientX = 0, startX = 0;
  const INTENT_PX = 8;

  // Boot / animation flags
  let bootAnimating = false;
  let userAnimating = false; // yellow 토글 등
  let dragOriginStatus = "unknown";

  function computeBounds() {
    const trackRect = el.getBoundingClientRect();
    const pillRect = pill.getBoundingClientRect();
    const leftPad = 10;
    const rightPad = 10;
    minX = 0;
    maxX = Math.max(0, trackRect.width - pillRect.width - leftPad - rightPad);
  }

  function progress(x) {
    if (maxX === minX) return 0.5;
    return (x - minX) / (maxX - minX);
  }

  // ✅ red/green 확정 시 의미는 "반대쪽 슬롯"에 노출
  // red 확정(왼쪽): 의미 = 오른쪽 슬롯
  // green 확정(오른쪽): 의미 = 왼쪽 슬롯
  function meaningOpacityRight(p){
    // p가 왼쪽으로 갈수록 오른쪽 meaning이 나타남
    if(p >= TH_LEFT) return 0;
    const t = (TH_LEFT - p) / TH_LEFT;
    return smoothstep(t);
  }
  function meaningOpacityLeft(p){
    // p가 오른쪽으로 갈수록 왼쪽 meaning이 나타남
    if(p <= TH_RIGHT) return 0;
    const t = (p - TH_RIGHT) / (1 - TH_RIGHT);
    return smoothstep(t);
  }

  function applyVisualByX(x){
    const p = progress(x);

    // tint continuous
    const leftStr  = Math.max(0, (0.5 - p) / 0.5);
    const rightStr = Math.max(0, (p - 0.5) / 0.5);
    tintL.style.opacity = String(Math.min(1, leftStr * 0.9));
    tintR.style.opacity = String(Math.min(1, rightStr * 0.9));

    // pill color continuous between red↔neutral↔green (drag용)
    // (yellow는 "상태" 전환으로 처리)
    let bg, bd;
    if(p <= 0.5){
      const t = p / 0.5;
      bg = mixRGBA(COL_RED_BG, COL_NEUTRAL_BG, t);
      bd = mixRGBA(COL_RED_BD, COL_NEUTRAL_BD, t);
    }else{
      const t = (p - 0.5) / 0.5;
      bg = mixRGBA(COL_NEUTRAL_BG, COL_GREEN_BG, t);
      bd = mixRGBA(COL_NEUTRAL_BD, COL_GREEN_BD, t);
    }
    // 단, yellow 상태면 아래에서 override 됨
    if(getStatus() !== "yellow"){
      pill.style.background = rgbaStr(bg);
      pill.style.borderColor = rgbaStr(bd);
    }

    // meaning opacity continuous (yellow는 slots 숨김)
    const opR = meaningOpacityRight(p);
    const opL = meaningOpacityLeft(p);

    if(getStatus() !== "yellow"){
      meanR.style.opacity = String(opR);
      meanL.style.opacity = String(opL);
      meanR.style.transform = `translateY(-50%) translateX(${Math.round(6 * (1 - opR))}px)`;
      meanL.style.transform = `translateY(-50%) translateX(${Math.round(-6 * (1 - opL))}px)`;
    }

    // ✅ unknown에서만 lights가 존재감을 갖고, (드래그/부트 중) 의미가 올라오면 lights 연속 fade
    const shouldFadeLights =
      (bootAnimating && dragOriginStatus === "unknown") ||
      (intent === "drag" && dragOriginStatus === "unknown");

    if(shouldFadeLights){
      const fade = clamp01(1 - Math.max(opR, opL));
      sigLR.style.opacity = String(fade);
      sigY.style.opacity  = String(Math.min(.75, .75 * fade));
    }else{
      sigLR.style.opacity = "";
      sigY.style.opacity  = "";
    }
  }

  function moveTo(x, snap){
    const clamped = Math.max(minX, Math.min(maxX, x));
    curX = clamped;
    if(snap) pill.classList.remove("dragging");
    pill.style.transform = `translateY(-50%) translateX(${clamped}px)`;
    applyVisualByX(clamped);
  }

  function setTrackClass(st){
    el.classList.remove("is-unknown","is-red","is-yellow","is-green");
    el.classList.add(
      st === "red" ? "is-red" :
      st === "green" ? "is-green" :
      st === "yellow" ? "is-yellow" : "is-unknown"
    );
  }

  function getStatus(){
    return wordObj.status || "unknown";
  }

  function statusToX(st){
    if(st === "red") return minX;
    if(st === "green") return maxX;
    // unknown/yellow은 중앙
    return (minX + maxX) / 2;
  }

  function snapByX(x, originStatus){
    const p = progress(x);
    if(p <= TH_LEFT) return "red";
    if(p >= TH_RIGHT) return "green";
    // 중앙 밴드: origin이 yellow면 yellow 유지, 아니면 unknown
    return originStatus === "yellow" ? "yellow" : "unknown";
  }

  function applyStatus(st, opts){
    const save = !(opts && opts.save === false);
    wordObj.status = st;
    if(save){
      state.words[index].status = st;
      saveState(state);
    }

    setTrackClass(st);

    // yellow면 pill 색을 yellow로 override
    if(st === "yellow"){
      pill.style.background = rgbaStr(COL_YELLOW_BG);
      pill.style.borderColor = rgbaStr(COL_YELLOW_BD);
    }
    if(st === "unknown"){
      // unknown은 neutral
      pill.style.background = rgbaStr(COL_NEUTRAL_BG);
      pill.style.borderColor = rgbaStr(COL_NEUTRAL_BD);
      // width도 base로 복귀
      pill.style.width = getBasePillWidth() + "px";
      setPillText(wordObj.word, true);
    }
    if(st === "red"){
      // 위치 기반으로 이미 색은 잡히지만, 확정 느낌을 위해 red로 살짝 당겨줌
      pill.style.background = rgbaStr(COL_RED_BG);
      pill.style.borderColor = rgbaStr(COL_RED_BD);
      pill.style.width = getBasePillWidth() + "px";
      setPillText(wordObj.word, true);
    }
    if(st === "green"){
      pill.style.background = rgbaStr(COL_GREEN_BG);
      pill.style.borderColor = rgbaStr(COL_GREEN_BD);
      pill.style.width = getBasePillWidth() + "px";
      setPillText(wordObj.word, true);
    }

    moveTo(statusToX(st), true);
  }

  function applyMeaningSizing(slotEl){
    const t = slotEl.textContent || "";
    slotEl.classList.remove("small","smaller");
    if(t.length >= 16) slotEl.classList.add("small");
    if(t.length >= 22) slotEl.classList.add("smaller");
  }

  /* =========================
     Pill text + width animation for yellow
  ========================= */
  function getBasePillWidth(){
    const css = getComputedStyle(document.documentElement).getPropertyValue("--pill-w").trim();
    const n = parseFloat(css);
    return Number.isFinite(n) ? n : 140;
  }

  function measureTextWidth(text){
    measureEl.textContent = text || "";
    // pill padding(좌우 14px) + 약간 여유
    const w = Math.ceil(measureEl.getBoundingClientRect().width);
    return w;
  }

  function clampPillWidth(targetPx){
    // track 내에서 너무 커지지 않게 상한
    const trackW = el.getBoundingClientRect().width || 360;
    const maxPx = Math.floor(trackW * 0.72); // 안전한 상한
    const minPx = getBasePillWidth();
    return Math.max(minPx, Math.min(maxPx, targetPx));
  }

  function setPillText(text, immediate){
    if(immediate){
      pill.classList.remove("swap-out","swap-in");
      pillText.textContent = text || "";
      return;
    }
    // fade out -> swap -> fade in
    pill.classList.add("swap-out");
    setTimeout(()=>{
      pillText.textContent = text || "";
      pill.classList.remove("swap-out");
      pill.classList.add("swap-in");
      setTimeout(()=> pill.classList.remove("swap-in"), getVarMs("--yellow-swap-ms", 220) + 10);
    }, getVarMs("--yellow-swap-ms", 220));
  }

  async function runYellowMeaningPulse(){
    if(userAnimating) return;
    userAnimating = true;

    const holdMs = getVarMs("--yellow-word-hold-ms", 120);
    const keepMeaningMs = getVarMs("--yellow-keep-meaning-ms", 520);
    const widthMs = getVarMs("--yellow-width-ms", 320);

    // 1) 잠깐 텀
    await wait(holdMs);

    // 2) 의미 텍스트로 바꾸며 width 확장
    const targetW = clampPillWidth(measureTextWidth(wordObj.meaning || ""));
    pill.style.transition = pill.style.transition || ""; // keep
    pill.style.width = targetW + "px";
    setPillText(wordObj.meaning || "", false);

    await wait(widthMs + keepMeaningMs);

    // 3) 영단어로 복귀하며 width 원복
    pill.style.width = getBasePillWidth() + "px";
    setPillText(wordObj.word, false);

    await wait(widthMs + 40);

    userAnimating = false;
  }

  function wait(ms){ return new Promise(r => setTimeout(r, ms)); }

  /* =========================
     Boot init (hold center -> rAF move, continuous)
  ========================= */
  let lastW = 0;
  function init(mode){
    computeBounds();

    const trackW = el.getBoundingClientRect().width;
    const widthChanged = Math.abs(trackW - lastW) > 2;
    lastW = trackW;

    const st = getStatus();

    if(mode === "resize" && !widthChanged) return;

    if(mode === "resize"){
      pill.classList.add("booting");
      bootAnimating = false;
      sigLR.style.opacity = "";
      sigY.style.opacity = "";

      setTrackClass(st);
      moveTo(statusToX(st), true);

      // 상태별 color 보정
      applyStatus(st, { save:false });

      requestAnimationFrame(()=> pill.classList.remove("booting"));
      return;
    }

    // boot
    const holdMs = getVarMs("--boot-hold-ms", 600);
    const moveMs = getVarMs("--boot-move-ms", 3000);

    dragOriginStatus = "unknown";
    bootAnimating = false;

    pill.classList.add("booting");
    setTrackClass("unknown");
    wordObj.status = "unknown";
    // neutral base
    pill.style.width = getBasePillWidth() + "px";
    pill.style.background = rgbaStr(COL_NEUTRAL_BG);
    pill.style.borderColor = rgbaStr(COL_NEUTRAL_BD);
    setPillText(wordObj.word, true);

    moveTo(statusToX("unknown"), true);

    requestAnimationFrame(()=>{
      el.classList.remove("preboot");

      // 저장 상태가 unknown이면 끝
      if(st === "unknown"){
        pill.classList.remove("booting");
        applyStatus("unknown", { save:false });
        return;
      }

      // 저장 상태가 yellow면: hold 후 중앙에서 yellow로 "서서히 점등" 느낌만 주고 끝
      if(st === "yellow"){
        setTimeout(()=>{
          pill.classList.remove("booting");
          applyStatus("yellow", { save:false });
        }, holdMs);
        return;
      }

      // red/green은 hold 후 rAF로 이동하면서 연속 변화
      setTimeout(()=>{
        bootAnimating = true;

        const fromX = statusToX("unknown");
        const toX   = statusToX(st);
        const t0 = performance.now();

        function step(now){
          const t = clamp01((now - t0) / moveMs);
          const e = easeInOutCubic(t);
          const x = lerp(fromX, toX, e);
          moveTo(x, false);

          if(t < 1){
            requestAnimationFrame(step);
          }else{
            bootAnimating = false;
            pill.classList.remove("booting");
            // 이동 끝에서 상태 확정(뚝변 방지)
            applyStatus(st, { save:false });
          }
        }
        requestAnimationFrame(step);
      }, holdMs);
    });
  }

  requestAnimationFrame(()=> init("boot"));
  let resizeT = null;
  window.addEventListener("resize", ()=>{
    clearTimeout(resizeT);
    resizeT = setTimeout(()=> init("resize"), 80);
  }, { passive:true });

  /* =========================
     Drag intent-based
  ========================= */
  pill.addEventListener("pointerdown", (e)=>{
    if(userAnimating) return; // yellow pulse 중엔 드래그 잠깐 막음 (원하면 제거 가능)

    pending = true;
    intent = null;
    pid = e.pointerId;

    dragOriginStatus = getStatus();

    computeBounds();
    downX = e.clientX;
    downY = e.clientY;

    startClientX = e.clientX;
    startX = curX;
  });

  pill.addEventListener("pointermove", (e)=>{
    if(!pending || e.pointerId !== pid) return;

    const dx0 = e.clientX - downX;
    const dy0 = e.clientY - downY;

    if(!intent){
      const adx = Math.abs(dx0);
      const ady = Math.abs(dy0);

      if(adx > INTENT_PX && adx > ady){
        intent = "drag";
        pill.setPointerCapture(pid);
        pill.classList.add("dragging");
        startClientX = e.clientX;
        startX = curX;

        // 드래그 시작 시 yellow였다면, 연속색/슬롯모드로 전환되며 중앙에서 빠져나갈 수 있게 허용
        // (yellow 고정색은 applyVisualByX에서 status 체크로 막히므로, 드래그 중에는 잠시 yellow 색 override 유지)
      }else if(ady > INTENT_PX && ady > adx){
        intent = "scroll";
        pending = false;
        return;
      }else{
        return;
      }
    }

    if(intent !== "drag") return;

    // 드래그 중에는 yellow도 X 기반 색감/연속 변화가 자연스러우니 잠시 허용:
    // => status가 yellow인 동안 applyVisualByX가 색을 override 못하게 했으므로,
    //    드래그 중엔 "가변색"이 필요하면 아래 한 줄을 켜면 됨.
    // 지금은 "yellow 유지" 쪽이 더 브랜드 안정적이라 그대로 둠.

    const dx = e.clientX - startClientX;
    moveTo(startX + dx, false);
    e.preventDefault();
  });

  function endDrag(e){
    if(e.pointerId !== pid) return;

    if(intent !== "drag"){
      pending = false;
      intent = null;
      return;
    }

    pending = false;
    pill.classList.remove("dragging");
    sigLR.style.opacity = "";
    sigY.style.opacity = "";

    const next = snapByX(curX, dragOriginStatus);
    applyStatus(next);

    intent = null;
    e.preventDefault();
  }

  pill.addEventListener("pointerup", endDrag);
  pill.addEventListener("pointercancel", endDrag);

  /* =========================
     Click actions
  ========================= */
  // Zones: left/right는 확정, center는 unknown (grey)로
  zoneL.addEventListener("click", ()=> applyStatus("red"));
  zoneR.addEventListener("click", ()=> applyStatus("green"));
  zoneC.addEventListener("click", ()=> applyStatus("unknown"));

  // Pill click: yellow 토글 + 의미 pulse
  // - unknown/red/green에서 클릭 => yellow로 전환 + meaning pulse
  // - yellow에서 클릭 => meaning pulse (색 유지)
  pill.addEventListener("click", async ()=>{
    if(userAnimating) return;

    const st = getStatus();
    if(st !== "yellow"){
      applyStatus("yellow");
      // yellow는 중앙 고정
      moveTo(statusToX("yellow"), true);
      await wait(40);
    }
    // yellow pulse 실행
    runYellowMeaningPulse();
  });

  // 초기 상태 반영 (render 직후 안전)
  applyStatus(getStatus(), { save:false });

  return el;
}

/* =========================
   Render
========================= */
let state = loadState();

function render() {
  listEl.innerHTML = "";
  const count = state.words.length;

  const remain = Math.max(0, 3 - state.chargeUsed);
  remainText.textContent = `${remain}/3`;
  btnCharge.disabled = remain <= 0;

  if (count === 0) {
    emptyState.style.display = "block";
    return;
  }
  emptyState.style.display = "none";

  state.words.forEach((w, idx) => {
    // 기존 v0/v1 데이터가 dont/know를 썼으면 자동 마이그레이션
    if(w.status === "dont") w.status = "red";
    if(w.status === "know") w.status = "green";
    if(!w.status) w.status = "unknown";

    listEl.appendChild(buildTrackRow(w, idx, state));
  });

  saveState(state);
}

/* =========================
   Charge modal
========================= */
btnCharge.addEventListener("click", () => {
  state = loadState();
  const remain = Math.max(0, 3 - state.chargeUsed);
  remainText.textContent = `${remain}/3`;
  dlgChargeDo.disabled = remain <= 0;
  dlgCharge.show();
});

dlgChargeClose.addEventListener("click", () => dlgCharge.hide());

dlgChargeDo.addEventListener("click", () => {
  state = loadState();
  const remain = 3 - state.chargeUsed;
  if (remain <= 0) {
    dlgCharge.hide();
    showToast("오늘 충전은 3회까지예요.");
    return;
  }
  state.words = state.words.concat(makeDummyWords(10));
  state.chargeUsed += 1;
  saveState(state);
  dlgCharge.hide();

  render();
  showToast(`충전 완료! +10개 (남은 ${Math.max(0, 3 - state.chargeUsed)}/3)`);
});

/* =========================
   Boot
========================= */
render();
requestAnimationFrame(() => document.documentElement.classList.add("ready"));
</script>

</body>
</html>
