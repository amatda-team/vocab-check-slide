<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>신호등보카 (Slide)</title>

  <!-- Shoelace (CDN) -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.15.0/cdn/themes/light.css">
  <script type="module" src="https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.15.0/cdn/shoelace.js"></script>

  <style>
    :root{
      --app-max: 520px;

      /* ✅ Boot motion controls */
      --boot-hold-ms: 600ms;
      --boot-move-ms: 2600ms;
      --boot-ease: cubic-bezier(.2,.9,.25,1);

      /* ✅ Peek controls */
      --peek-in-ms: 120ms;
      --peek-hold-ms: 520ms;
      --peek-out-ms: 260ms;

      /* Theme */
      --bg0: #070a10;
      --bg1: #0b0f14;

      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.58);

      --track: rgba(255,255,255,.06);
      --line: rgba(255,255,255,.10);

      --radius: 18px;
      --pill-radius: 999px;

      --track-h: 72px;
      --pill-h: 44px;
      --pill-w: 140px;

      --pad: 12px;
      --lr-pad: 12px;

      /* Lights */
      --red:   255, 90,  90;
      --green:  80, 220, 140;
      --amber: 255, 170,  70;

      /* Unknown pill transparency (yellow light recognition) */
      --unknown-pill-alpha: .14;
      --unknown-pill-bd-alpha: .10;
    }

    *{ box-sizing: border-box; }

    html{ background: var(--bg0); }
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Apple SD Gothic Neo", "Noto Sans KR", Arial, "Helvetica Neue", sans-serif;
      color: var(--text);
      min-height: 100svh;
      background: transparent;
    }
    body::before{
      content:"";
      position: fixed;
      inset: 0;
      z-index: -1;
      pointer-events: none;
      background:
        radial-gradient(1200px 800px at 50% -200px, rgba(80,130,255,.18), transparent 60%),
        linear-gradient(180deg, var(--bg0), var(--bg1) 40%, var(--bg0));
      transform: translateZ(0);
    }

    sl-dialog:not(:defined){ display:none !important; }
    sl-alert:not(:defined){ display:none !important; }
    sl-button:not(:defined){ visibility:hidden; }

    .app{
      max-width: var(--app-max);
      margin: 0 auto;
      padding: 18px var(--pad) 120px;
    }

    .header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 12px;
      margin: 6px 0 12px;
    }
    .header h1{
      margin: 0;
      font-size: 28px;
      letter-spacing: -.4px;
      font-weight: 900;
      line-height: 1.1;
    }

    .toast-wrap{
      position: sticky;
      top: 10px;
      z-index: 999;
      padding: 0 var(--pad);
    }
    .toast-wrap sl-alert{
      max-width: var(--app-max);
      margin: 0 auto;
      border-radius: 14px;
    }

    .list{
      display:flex;
      flex-direction:column;
      gap: 14px;
      margin-top: 12px;
    }

    .empty{
      margin-top: 18px;
      padding: 18px;
      border: 1px dashed rgba(255,255,255,.16);
      border-radius: 16px;
      color: var(--muted);
      text-align:center;
      line-height: 1.6;
    }
    .empty b{ color: var(--text); }

    /* Track */
    .track{
      position: relative;
      height: var(--track-h);
      border-radius: var(--radius);
      background: var(--track);
      border: 1px solid var(--line);
      overflow: hidden;
      -webkit-tap-highlight-color: transparent;
      transition: opacity .16s ease, transform .16s ease;
    }
    .track.preboot{ opacity: 0; transform: translateY(2px); }

    /* Continuous tints (red/green + amber ambiance) */
    .tint{
      position:absolute;
      inset:0;
      opacity: 0;
      pointer-events:none;
      transition: opacity .10s linear;
    }
    .tint.left{
      background: radial-gradient(640px 260px at 0% 55%, rgba(255,90,90,.22), transparent 62%);
    }
    .tint.right{
      background: radial-gradient(640px 260px at 100% 55%, rgba(80,220,140,.22), transparent 62%);
    }
    /* ✅ yellow도 좌우로 은은하게 */
    .tint.amberL{
      background: radial-gradient(640px 260px at 0% 55%, rgba(255,170,70,.14), transparent 62%);
    }
    .tint.amberR{
      background: radial-gradient(640px 260px at 100% 55%, rgba(255,170,70,.14), transparent 62%);
    }

    /* Lights layer */
    .lights{
      position:absolute;
      inset:0;
      pointer-events:none;
      z-index: 1;
    }
    .light{
      position:absolute;
      top: 50%;
      width: 16px;
      height: 16px;
      border-radius: 999px;
      transform: translateY(-50%);
      opacity: .55; /* will be overridden inline */
      filter: saturate(1.05);
    }
    .light.left{ left: var(--lr-pad); }
    .light.right{ right: var(--lr-pad); }
    /* yellow light "under pill" 느낌: 가운데 + z축(뒤) */
    .light.center{
      left: 50%;
      transform: translate(-50%, -50%);
      width: 18px;
      height: 18px;
    }

    .light::after{
      content:"";
      position:absolute;
      inset:-18px;
      border-radius: 999px;
      opacity: .65;
      filter: blur(10px);
      background: radial-gradient(circle, rgba(255,255,255,.35), transparent 60%);
      mix-blend-mode: screen;
    }

    /* Meaning slots */
    .meaning-slot{
      position:absolute;
      top: 50%;
      transform: translateY(-50%);
      width: 46%;
      padding: 0 var(--lr-pad);
      pointer-events:none;

      opacity: 0;
      transition: opacity .10s linear, transform .16s ease;

      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;

      font-size: 14px;
      font-weight: 600;
      letter-spacing: -.2px;
      color: rgba(255,255,255,.78);
      z-index: 2;
    }
    .meaning-left{ left: 0; text-align:left; }
    .meaning-right{ right: 0; text-align:right; }
    .meaning-slot.small{ font-size: 13px; }
    .meaning-slot.smaller{ font-size: 12px; }

    /* Click zones */
    .zone{
      position:absolute;
      top:0; bottom:0;
      z-index: 3;
      background: transparent;
    }
    .zone.left{ left:0; width:34%; }
    .zone.center{ left:33%; width:34%; }
    .zone.right{ right:0; width:34%; }

    /* Pill (center-anchored so width expands symmetrically) */
    .pill{
      position:absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) translateX(0px);
      height: var(--pill-h);
      width: var(--pill-w);
      border-radius: var(--pill-radius);

      background: rgba(230,235,245,.22);
      border: 1px solid rgba(255,255,255,.14);

      display:flex;
      align-items:center;
      justify-content:center;
      padding: 0 14px;

      user-select:none;
      -webkit-user-select:none;

      /* 기본은 세로 스크롤 허용 */
      touch-action: pan-y;

      will-change: transform, background, border-color, width;
      transition:
        transform .18s cubic-bezier(.2,.9,.25,1),
        background .10s linear,
        border-color .10s linear,
        width .22s ease;

      z-index: 4;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .pill.dragging{
      transition:none !important;
      touch-action: none;
    }
    .pill.booting{ transition: none !important; }

    /* Text inside pill */
    .pill-text{
      display:block;
      width: 100%;
      text-align:center;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;

      /* default(word) */
      font-weight: 900;
      letter-spacing: -.2px;
      color: rgba(255,255,255,.92);
      transition: opacity .12s ease;
    }

    /* meaning style inside pill (yellow peek) */
    .pill.is-meaning .pill-text{
      font-weight: 600;
      color: rgba(255,255,255,.78);
    }

    /* Unknown pill more transparent to reveal center amber light */
    .track.is-unknown .pill{
      background: rgba(230,235,245,var(--unknown-pill-alpha));
      border-color: rgba(255,255,255,var(--unknown-pill-bd-alpha));
    }

    /* Footer */
    .footer{
      position: fixed;
      left:0; right:0; bottom:0;
      padding: 12px var(--pad) calc(12px + env(safe-area-inset-bottom));
      background: linear-gradient(180deg, transparent, rgba(0,0,0,.35) 25%, rgba(0,0,0,.55));
      backdrop-filter: blur(10px);
      z-index: 50;

      opacity: 0;
      transform: translateY(8px);
      pointer-events:none;
      transition: opacity .18s ease, transform .18s ease;
    }
    html.ready .footer{
      opacity: 1;
      transform: translateY(0);
      pointer-events:auto;
    }
    .footer-inner{
      max-width: var(--app-max);
      margin: 0 auto;
    }

    /* Shoelace tweaks */
    sl-dialog::part(panel){
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(20,24,32,.96);
      color: var(--text);
    }
    sl-dialog::part(title){
      font-weight: 900;
      letter-spacing: -.2px;
    }
    sl-button::part(base){ border-radius: 14px; }

    .charge-msg{
      font-size: 14px;
      color: rgba(255,255,255,.86);
      line-height: 1.5;
      margin-bottom: 10px;
    }
    .charge-remain{
      font-size: 12px;
      color: var(--muted);
      margin-bottom: 14px;
    }
    .btn-row{ display:flex; gap: 10px; }
    .btn-row sl-button{ flex: 1 1 0; }
    .btn-row sl-button::part(base){ width: 100%; }

    /* hidden measurer */
    .measure{
      position: absolute;
      left: -9999px;
      top: -9999px;
      visibility: hidden;
      white-space: nowrap;
      font-size: 14px;
      font-weight: 600;
      letter-spacing: -.2px;
    }
  </style>
</head>

<body>
  <div class="toast-wrap" aria-live="polite" aria-atomic="true">
    <sl-alert id="toast" variant="primary" duration="2200" closable>
      <sl-icon slot="icon" name="info-circle"></sl-icon>
      <span id="toastText">안내</span>
    </sl-alert>
  </div>

  <main class="app">
    <div class="header">
      <h1>오늘의 단어</h1>
      <sl-button id="btnCharge" variant="primary">충전하기</sl-button>
    </div>

    <div id="emptyState" class="empty" style="display:none;">
      아직 오늘의 단어가 <b>0개</b>예요.<br>
      상단의 <b>충전하기</b>로 10개씩 추가해 주세요.
    </div>

    <div id="list" class="list"></div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      <sl-button id="ctaSubmit" variant="neutral" outline disabled style="width:100%;">제출하기 (Phase 2~)</sl-button>
    </div>
  </footer>

  <!-- Charge dialog -->
  <sl-dialog id="dlgCharge" label="충전하기">
    <div class="charge-msg">한 번에 10개씩 충전이 가능해요</div>
    <div class="charge-remain">오늘 남은 횟수 <b id="remainText">3/3</b></div>

    <div class="btn-row">
      <sl-button id="dlgChargeDo" variant="primary">충전하기</sl-button>
      <sl-button id="dlgChargeClose" variant="default" outline>닫기</sl-button>
    </div>
  </sl-dialog>

  <span id="measurer" class="measure"></span>

  <script>
  /* =========================
     Storage / State
  ========================= */
  const LS_KEY = "signal_vocab_v1"; // ✅ 새 키(혼선 방지)
  const todayKey = (() => {
    const d = new Date();
    const y = d.getFullYear();
    const m = String(d.getMonth() + 1).padStart(2, "0");
    const day = String(d.getDate()).padStart(2, "0");
    return `${y}-${m}-${day}`;
  })();

  function loadState() {
    try {
      const raw = localStorage.getItem(LS_KEY);
      if (!raw) return { day: todayKey, chargeUsed: 0, words: [] };
      const s = JSON.parse(raw);
      if (s.day !== todayKey) return { day: todayKey, chargeUsed: 0, words: [] };
      return {
        day: s.day || todayKey,
        chargeUsed: Number(s.chargeUsed || 0),
        words: Array.isArray(s.words) ? s.words : []
      };
    } catch (e) {
      return { day: todayKey, chargeUsed: 0, words: [] };
    }
  }
  function saveState(state) {
    localStorage.setItem(LS_KEY, JSON.stringify(state));
  }

  function makeDummyWords(n) {
    const pool = [
      ["abandon", "버리다, 포기하다"],
      ["accurate", "정확한"],
      ["benevolent", "자비로운, 선의의"],
      ["consequence", "결과, 영향"],
      ["diligent", "성실한"],
      ["elaborate", "정교한, 상세히 설명하다"],
      ["friction", "마찰, 충돌"],
      ["gratitude", "감사"],
      ["hesitate", "망설이다"],
      ["inevitable", "피할 수 없는"]
    ];
    const out = [];
    const base = Date.now().toString(36);
    for (let i = 0; i < n; i++) {
      const pick = pool[Math.floor(Math.random() * pool.length)];
      out.push({
        id: `${base}-${i}-${Math.random().toString(16).slice(2, 8)}`,
        word: pick[0],
        meaning: pick[1],
        status: "unknown",      // unknown | red | yellow | green
        touched: false          // ✅ unknown은 최초 1회 상호작용 이후 돌아오지 않음
      });
    }
    return out;
  }

  /* =========================
     UI refs
  ========================= */
  const toast = document.getElementById("toast");
  const toastText = document.getElementById("toastText");

  const btnCharge = document.getElementById("btnCharge");
  const dlgCharge = document.getElementById("dlgCharge");
  const dlgChargeDo = document.getElementById("dlgChargeDo");
  const dlgChargeClose = document.getElementById("dlgChargeClose");
  const remainText = document.getElementById("remainText");

  const listEl = document.getElementById("list");
  const emptyState = document.getElementById("emptyState");
  const measurer = document.getElementById("measurer");

  function showToast(msg) {
    toastText.textContent = msg;
    toast.toast();
  }

  function escapeHtml(s) {
    return String(s)
      .replaceAll("&", "&amp;")
      .replaceAll("<", "&lt;")
      .replaceAll(">", "&gt;")
      .replaceAll('"', "&quot;")
      .replaceAll("'", "&#039;");
  }

  /* =========================
     Helpers
  ========================= */
  function lerp(a, b, t) { return a + (b - a) * t; }
  function clamp01(x) { return Math.max(0, Math.min(1, x)); }
  function smoothstep(t) {
    t = clamp01(t);
    return t * t * (3 - 2 * t);
  }
  function easeInOutCubic(t){
    t = clamp01(t);
    return t < 0.5 ? 4*t*t*t : 1 - Math.pow(-2*t + 2, 3) / 2;
  }

  function parseMs(str, fallback) {
    const s = String(str || "").trim();
    if (!s) return fallback;
    if (s.endsWith("ms")) return parseFloat(s);
    if (s.endsWith("s")) return parseFloat(s) * 1000;
    const n = parseFloat(s);
    return Number.isFinite(n) ? n : fallback;
  }
  function getVarMs(name, fallback) {
    const v = getComputedStyle(document.documentElement).getPropertyValue(name);
    return parseMs(v, fallback);
  }

  function rgba(rgb, a){
    return `rgba(${rgb[0]},${rgb[1]},${rgb[2]},${a})`;
  }

  const RGB_RED   = [255, 90, 90];
  const RGB_GREEN = [80, 220, 140];
  const RGB_AMBER = [255, 170, 70];

  /* =========================
     Track builder
  ========================= */
  function buildTrackRow(wordObj, index, state) {
    const el = document.createElement("div");
    el.className = "track is-unknown preboot";
    el.dataset.index = String(index);

    el.innerHTML = `
      <div class="tint left"></div>
      <div class="tint right"></div>
      <div class="tint amberL"></div>
      <div class="tint amberR"></div>

      <div class="lights">
        <div class="light left"></div>
        <div class="light center"></div>
        <div class="light right"></div>
      </div>

      <div class="meaning-slot meaning-left"></div>
      <div class="meaning-slot meaning-right"></div>

      <div class="zone left" aria-label="왼쪽(RED)"></div>
      <div class="zone center" aria-label="가운데(YELLOW)"></div>
      <div class="zone right" aria-label="오른쪽(GREEN)"></div>

      <div class="pill" role="button" aria-label="단어 필">
        <span class="pill-text">${escapeHtml(wordObj.word)}</span>
      </div>
    `;

    const tintL   = el.querySelector(".tint.left");
    const tintR   = el.querySelector(".tint.right");
    const tintAL  = el.querySelector(".tint.amberL");
    const tintAR  = el.querySelector(".tint.amberR");

    const lightL  = el.querySelector(".light.left");
    const lightC  = el.querySelector(".light.center");
    const lightR  = el.querySelector(".light.right");

    const pill    = el.querySelector(".pill");
    const pillTxt = el.querySelector(".pill-text");

    const meanL   = el.querySelector(".meaning-left");
    const meanR   = el.querySelector(".meaning-right");

    const zoneL   = el.querySelector(".zone.left");
    const zoneC   = el.querySelector(".zone.center");
    const zoneR   = el.querySelector(".zone.right");

    // meaning content (slots)
    meanL.textContent = wordObj.meaning || "";
    meanR.textContent = wordObj.meaning || "";
    applyMeaningSizing(meanL);
    applyMeaningSizing(meanR);

    // X is centered: [-max..+max], 0 is center
    let minX = 0, maxX = 0, curX = 0;

    // 중앙 밴드(=yellow)
    const TH_LEFT  = 0.40;
    const TH_RIGHT = 0.60;

    // drag intent
    let pending = false;
    let intent = null; // "drag" | "scroll" | null
    let pid = null;
    let downX = 0, downY = 0;
    let startClientX = 0, startX = 0;
    const INTENT_PX = 8;

    // animation flags
    let bootAnimating = false;
    let peekTimer = null;

    // peek multipliers (stable state에서는 0, peek 때만 올라옴)
    let peekL = 0, peekR = 0;

    function computeBounds() {
      const trackRect = el.getBoundingClientRect();
      const pillRect  = pill.getBoundingClientRect();
      const pad = 10;
      const half = trackRect.width / 2;
      const halfP = pillRect.width / 2;
      // center-anchored bounds
      minX = -(half - halfP - pad);
      maxX = +(half - halfP - pad);
      if(!Number.isFinite(minX) || !Number.isFinite(maxX)){
        minX = -120; maxX = 120;
      }
    }

    function progress01(x){
      if (maxX === minX) return 0.5;
      return (x - minX) / (maxX - minX);
    }

    function statusToX(st){
      if(st === "red") return minX;
      if(st === "green") return maxX;
      // yellow or unknown
      return 0;
    }

    function snapByX(x){
      const p = progress01(x);
      if(p <= TH_LEFT) return "red";
      if(p >= TH_RIGHT) return "green";
      return "yellow";
    }

    function setTrackClass(st){
      el.classList.remove("is-unknown","is-red","is-yellow","is-green");
      el.classList.add(
        st === "red" ? "is-red" :
        st === "green" ? "is-green" :
        st === "yellow" ? "is-yellow" : "is-unknown"
      );
    }

    function setPillColorByProgress(p){
      // 3-stop mix: red <-> amber <-> green
      // (visual feels "신호등"이지만 여전히 테마 유지)
      let rgb, a = 0.30;
      let bdA = 0.32;

      if(p <= 0.5){
        const t = p / 0.5; // 0..1 (red->amber)
        rgb = [
          Math.round(lerp(RGB_RED[0], RGB_AMBER[0], t)),
          Math.round(lerp(RGB_RED[1], RGB_AMBER[1], t)),
          Math.round(lerp(RGB_RED[2], RGB_AMBER[2], t)),
        ];
      }else{
        const t = (p - 0.5) / 0.5; // 0..1 (amber->green)
        rgb = [
          Math.round(lerp(RGB_AMBER[0], RGB_GREEN[0], t)),
          Math.round(lerp(RGB_AMBER[1], RGB_GREEN[1], t)),
          Math.round(lerp(RGB_AMBER[2], RGB_GREEN[2], t)),
        ];
      }

      pill.style.background = `rgba(${rgb[0]},${rgb[1]},${rgb[2]},${a})`;
      pill.style.borderColor = `rgba(${rgb[0]},${rgb[1]},${rgb[2]},${bdA})`;
    }

    function applyLightsAndTints(x){
      const p = progress01(x);

      // intensities
      const redI   = smoothstep(clamp01((0.5 - p)/0.5));
      const greenI = smoothstep(clamp01((p - 0.5)/0.5));
      const yellowI = smoothstep(clamp01(1 - (Math.abs(p - 0.5) / 0.5))); // peak at center

      // edge fade so red light disappears when snapped fully red; same for green
      const leftEdgeFade  = smoothstep(clamp01(p / TH_LEFT));                // 0 at very left, 1 by TH_LEFT
      const rightEdgeFade = smoothstep(clamp01((1 - p) / (1 - TH_RIGHT)));   // 0 at very right, 1 by TH_RIGHT

      // center light should be visible in unknown/approach, but fade when "yellow snapped"
      // => while dragging/boot, keep it; when stable yellow, fade it
      const stable = (!bootAnimating && intent !== "drag");
      const current = getStableStatus();

      // lights opacity
      const oL = clamp01(redI * leftEdgeFade);
      const oR = clamp01(greenI * rightEdgeFade);

      // center light:
      // - unknown: visible to hint yellow exists
      // - while dragging/boot: visible (continuous)
      // - stable yellow: fade out (pill itself is amber, so label/light is not needed)
      let oC = yellowI * 0.95;
      if(stable && current === "yellow") oC *= 0.0;
      if(stable && current === "red") oC *= 0.0;
      if(stable && current === "green") oC *= 0.0;

      // set light colors + glows
      setLightStyle(lightL, RGB_RED,   oL);
      setLightStyle(lightR, RGB_GREEN, oR);
      setLightStyle(lightC, RGB_AMBER, oC);

      // tints
      tintL.style.opacity  = String(Math.min(1, redI * 0.9));
      tintR.style.opacity  = String(Math.min(1, greenI * 0.9));
      // amber tints also continuous
      tintAL.style.opacity = String(Math.min(1, yellowI * 0.55));
      tintAR.style.opacity = String(Math.min(1, yellowI * 0.55));

      // pill color:
      // - stable red/green/yellow => lock to that color
      // - dragging/boot => continuous by p
      if(intent === "drag" || bootAnimating){
        setPillColorByProgress(p);
      }else{
        const st = getStableStatus();
        if(st === "red") setPillColorByProgress(0.0);
        else if(st === "green") setPillColorByProgress(1.0);
        else if(st === "yellow") setPillColorByProgress(0.5);
        else {
          // unknown: keep more transparent (CSS already does it) but still keep subtle neutral
          pill.style.background = "";
          pill.style.borderColor = "";
        }
      }

      // meaning opacity:
      // - dragging/boot: continuous (so 겹침 없음)
      // - stable: only peek (peekL/peekR)
      let opL = 0, opR = 0;
      if(intent === "drag" || bootAnimating){
        // show opposing slot depending on direction continuously
        // red side -> right meaning, green side -> left meaning
        opR = smoothstep(clamp01((TH_LEFT - p) / TH_LEFT));            // 1 at left, 0 near TH_LEFT
        opL = smoothstep(clamp01((p - TH_RIGHT) / (1 - TH_RIGHT)));    // 0 near TH_RIGHT, 1 at right
      }
      // apply peek overlay
      opL = Math.max(opL, peekL);
      opR = Math.max(opR, peekR);

      meanL.style.opacity = String(opL);
      meanR.style.opacity = String(opR);

      // micro motion
      meanR.style.transform = `translateY(-50%) translateX(${Math.round(6*(1-opR))}px)`;
      meanL.style.transform = `translateY(-50%) translateX(${Math.round(-6*(1-opL))}px)`;
    }

    function setLightStyle(node, rgb, opacity){
      const a = clamp01(opacity);
      node.style.opacity = String(a);
      node.style.background = rgba(rgb, 0.92);
      // glow intensity
      const glowA = 0.55 * a;
      const glowB = 0.25 * a;
      node.style.boxShadow = `
        0 0 ${Math.round(14 + 20*a)}px rgba(${rgb[0]},${rgb[1]},${rgb[2]},${glowA}),
        0 0 ${Math.round(30 + 44*a)}px rgba(${rgb[0]},${rgb[1]},${rgb[2]},${glowB})
      `;
    }

    function moveTo(x, snap){
      const clamped = Math.max(minX, Math.min(maxX, x));
      curX = clamped;
      if(snap) pill.classList.remove("dragging");
      pill.style.transform = `translate(-50%, -50%) translateX(${clamped}px)`;
      applyLightsAndTints(clamped);
    }

    function getStableStatus(){
      return wordObj.status || "unknown";
    }

    function markTouched(){
      if(!wordObj.touched){
        wordObj.touched = true;
        state.words[index].touched = true;
      }
    }

    function applyStatus(nextStatus, opts){
      const save = !(opts && opts.save === false);
      const prev = getStableStatus();

      // ✅ unknown은 최초 상호작용 이후 돌아오지 않음
      if(prev !== "unknown" && nextStatus === "unknown"){
        nextStatus = "yellow";
      }

      if(prev === "unknown"){
        // 첫 변화 순간부터 touched
        markTouched();
        if(nextStatus === "unknown") nextStatus = "yellow";
      }

      const changed = (prev !== nextStatus);

      // set status
      wordObj.status = nextStatus;
      state.words[index].status = nextStatus;

      if(save){
        saveState(state);
      }

      // snap to exact pos
      setTrackClass(nextStatus);
      moveTo(statusToX(nextStatus), true);

      // ✅ 규칙: "어떤 상태이든 변화하면 meaning peek"
      // ✅ 또한 "같은 영역 클릭해도 meaning peek"
      triggerPeek(nextStatus, { from: prev, changed });
    }

    /* =========================
       Peek behaviors
       - red/green: meaning 슬롯 잠깐 표시
       - yellow: pill 내부에서 word↔meaning + 폭 확장/복귀
  ========================= */
    function clearPeekTimers(){
      if(peekTimer) { clearTimeout(peekTimer); peekTimer = null; }
    }

    function triggerPeek(st){
      clearPeekTimers();

      const inMs   = getVarMs("--peek-in-ms", 120);
      const holdMs = getVarMs("--peek-hold-ms", 520);
      const outMs  = getVarMs("--peek-out-ms", 260);

      // reset slot peek
      peekL = 0; peekR = 0;

      // cancel any pill width override before starting
      pill.classList.remove("is-meaning");
      pillTxt.style.opacity = "1";
      pill.style.width = ""; // back to css var

      // red/green: show meaning in side slot for a moment (and then hide)
      if(st === "red"){
        // meaning on RIGHT slot
        peekR = 1;
        applyLightsAndTints(curX);

        peekTimer = setTimeout(()=>{
          // fade out
          peekR = 0;
          applyLightsAndTints(curX);
        }, inMs + holdMs + outMs);

        return;
      }

      if(st === "green"){
        // meaning on LEFT slot
        peekL = 1;
        applyLightsAndTints(curX);

        peekTimer = setTimeout(()=>{
          peekL = 0;
          applyLightsAndTints(curX);
        }, inMs + holdMs + outMs);

        return;
      }

      // yellow: pill 내부에서 word -> meaning -> word (폭도 필요 시 확장)
      if(st === "yellow"){
        const baseW = getComputedStyle(pill).width;
        const basePx = parseFloat(baseW) || 140;

        // measure meaning width (meaning font)
        measurer.textContent = wordObj.meaning || "";
        const measW = measurer.getBoundingClientRect().width;
        // padding inside pill roughly 28px + a little breathing
        const target = Math.ceil(measW + 28 + 18);

        // cap by track width
        const trackW = el.getBoundingClientRect().width;
        const maxW = Math.max(basePx, trackW - 20);
        const targetW = Math.min(maxW, Math.max(basePx, target));

        // step1: fade out word
        pillTxt.style.opacity = "0";

        setTimeout(()=>{
          // swap to meaning
          pill.classList.add("is-meaning");
          pillTxt.textContent = wordObj.meaning || "";
          pill.style.width = `${targetW}px`; // symmetric because center-anchored
          pillTxt.style.opacity = "1";

          // hold then back to word
          peekTimer = setTimeout(()=>{
            pillTxt.style.opacity = "0";

            setTimeout(()=>{
              pill.classList.remove("is-meaning");
              pillTxt.textContent = wordObj.word || "";
              pill.style.width = ""; // back to base
              pillTxt.style.opacity = "1";
            }, outMs);

          }, holdMs);

        }, inMs);

        return;
      }

      // unknown: 첫 상호작용 이전엔 peek를 굳이 하지 않지만,
      // 규칙상 "변화"는 yellow로 일어나므로 여기 들어올 일은 거의 없음.
    }

    function applyMeaningSizing(slotEl){
      const t = slotEl.textContent || "";
      slotEl.classList.remove("small","smaller");
      if(t.length >= 16) slotEl.classList.add("small");
      if(t.length >= 22) slotEl.classList.add("smaller");
    }

    /* =========================
       Init (boot + resize-safe)
    ========================= */
    let lastW = 0;

    function init(mode){
      computeBounds();

      const trackW = el.getBoundingClientRect().width;
      const widthChanged = Math.abs(trackW - lastW) > 2;
      lastW = trackW;

      const st = getStableStatus();

      if(mode === "resize" && !widthChanged) return;

      if(mode === "resize"){
        pill.classList.add("booting");
        bootAnimating = false;
        peekL = 0; peekR = 0;
        setTrackClass(st);
        moveTo(statusToX(st), true);
        requestAnimationFrame(()=> pill.classList.remove("booting"));
        return;
      }

      // boot: center hold -> ease move to saved state (연속 변화)
      const holdMs = getVarMs("--boot-hold-ms", 600);
      const moveMs = getVarMs("--boot-move-ms", 2600);

      pill.classList.add("booting");
      bootAnimating = false;
      peekL = 0; peekR = 0;

      // start in center (unknown visuals)
      setTrackClass("unknown");
      moveTo(0, true);

      requestAnimationFrame(()=>{
        el.classList.remove("preboot");

        // if saved status is unknown OR untouched -> just settle
        if(st === "unknown" || !wordObj.touched){
          pill.classList.remove("booting");
          applyLightsAndTints(curX);
          return;
        }

        setTimeout(()=>{
          bootAnimating = true;
          const fromX = 0;
          const toX = statusToX(st);
          const t0 = performance.now();

          function step(now){
            const t = clamp01((now - t0) / moveMs);
            const e = easeInOutCubic(t);
            const x = lerp(fromX, toX, e);
            moveTo(x, false);

            if(t < 1){
              requestAnimationFrame(step);
            }else{
              bootAnimating = false;
              pill.classList.remove("booting");
              setTrackClass(st);
              moveTo(toX, true);

              // ✅ 규칙: "변화하면 peek"
              // boot는 "상태로 들어오는 순간"이 있으니 한번 peek
              triggerPeek(st);
            }
          }

          requestAnimationFrame(step);
        }, holdMs);
      });
    }

    requestAnimationFrame(()=> init("boot"));

    let resizeT = null;
    window.addEventListener("resize", ()=>{
      clearTimeout(resizeT);
      resizeT = setTimeout(()=> init("resize"), 80);
    }, { passive:true });

    /* =========================
       Drag (intent-based)
    ========================= */
    pill.addEventListener("pointerdown", (e)=>{
      pending = true;
      intent = null;
      pid = e.pointerId;

      computeBounds();
      downX = e.clientX;
      downY = e.clientY;

      startClientX = e.clientX;
      startX = curX;
      // preventDefault 금지(스크롤 우선)
    });

    pill.addEventListener("pointermove", (e)=>{
      if(!pending || e.pointerId !== pid) return;

      const dx0 = e.clientX - downX;
      const dy0 = e.clientY - downY;

      if(!intent){
        const adx = Math.abs(dx0);
        const ady = Math.abs(dy0);

        if(adx > INTENT_PX && adx > ady){
          intent = "drag";
          pill.setPointerCapture(pid);
          pill.classList.add("dragging");
          startClientX = e.clientX;
          startX = curX;
        }else if(ady > INTENT_PX && ady > adx){
          intent = "scroll";
          pending = false;
          return;
        }else{
          return;
        }
      }

      if(intent !== "drag") return;

      // moving => continuous visuals
      const dx = e.clientX - startClientX;
      moveTo(startX + dx, false);

      e.preventDefault();
    });

    function endPointer(e){
      if(e.pointerId !== pid) return;

      // TAP (no drag) => treat as "current region click" with peek (and state change if needed)
      if(intent !== "drag"){
        pending = false;
        intent = null;

        // a tap on pill should behave like tapping the region it's sitting in
        const st = getStableStatus();
        if(st === "unknown"){
          applyStatus("yellow");
        }else{
          applyStatus(st); // same state => peek
        }
        return;
      }

      // drag end
      pending = false;
      pill.classList.remove("dragging");

      const snapped = snapByX(curX);
      applyStatus(snapped);

      intent = null;
      e.preventDefault();
    }

    pill.addEventListener("pointerup", endPointer);
    pill.addEventListener("pointercancel", endPointer);

    /* =========================
       Zones clicks
       - left => red
       - center => yellow (NEVER unknown)
       - right => green
       - same state click => peek
    ========================= */
    zoneL.addEventListener("click", ()=> applyStatus("red"));
    zoneR.addEventListener("click", ()=> applyStatus("green"));
    zoneC.addEventListener("click", ()=> applyStatus("yellow"));

    // initial visuals
    applyLightsAndTints(curX);

    return el;
  }

  /* =========================
     Render
  ========================= */
  let state = loadState();

  function render() {
    listEl.innerHTML = "";
    const count = state.words.length;

    const remain = Math.max(0, 3 - state.chargeUsed);
    remainText.textContent = `${remain}/3`;
    btnCharge.disabled = remain <= 0;

    if (count === 0) {
      emptyState.style.display = "block";
      return;
    }
    emptyState.style.display = "none";

    state.words.forEach((w, idx) => {
      listEl.appendChild(buildTrackRow(w, idx, state));
    });
  }

  /* =========================
     Charge modal
  ========================= */
  btnCharge.addEventListener("click", () => {
    state = loadState();
    const remain = Math.max(0, 3 - state.chargeUsed);
    remainText.textContent = `${remain}/3`;
    dlgChargeDo.disabled = remain <= 0;
    dlgCharge.show();
  });

  dlgChargeClose.addEventListener("click", () => dlgCharge.hide());

  dlgChargeDo.addEventListener("click", () => {
    state = loadState();
    const remain = 3 - state.chargeUsed;
    if (remain <= 0) {
      dlgCharge.hide();
      showToast("오늘 충전은 3회까지예요.");
      return;
    }
    state.words = state.words.concat(makeDummyWords(10));
    state.chargeUsed += 1;
    saveState(state);
    dlgCharge.hide();

    render();
    showToast(`충전 완료! +10개 (남은 ${Math.max(0, 3 - state.chargeUsed)}/3)`);
  });

  /* =========================
     Boot
  ========================= */
  render();
  requestAnimationFrame(() => document.documentElement.classList.add("ready"));
  </script>
</body>
</html>
