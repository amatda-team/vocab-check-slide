<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>신호등보카 (Rebuild v1.1)</title>

  <!-- Shoelace (CDN) -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.15.0/cdn/themes/light.css">
  <script type="module" src="https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.15.0/cdn/shoelace.js"></script>

  <style>
    :root{
      --app-max: 520px;

      /* timings */
      --move-ms: 360ms;
      --peek-in-ms: 120ms;
      --peek-hold-ms: 560ms;
      --peek-out-ms: 200ms;

      /* Theme */
      --bg0: #070a10;
      --bg1: #0b0f14;

      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.58);

      --track: rgba(255,255,255,.06);
      --line: rgba(255,255,255,.10);

      --radius: 18px;
      --pill-radius: 999px;

      --track-h: 72px;

      /* pill */
      --pill-h: 44px;
      --pill-minw: 140px;
      --pill-pad-x: 14px;
      --pill-bd: 1px;

      --pad: 12px;

      /* edges */
      --edge-pad: 10px;

      /* Lights */
      --red:   255, 90,  90;
      --green:  80, 220, 140;
      --amber: 255, 170,  70;

      /* default pill (처음) */
      --default-pill-alpha: .18;
      --default-pill-bd-alpha: .12;
    }

    *{ box-sizing:border-box; }
    html{ background: var(--bg0); }
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Apple SD Gothic Neo", "Noto Sans KR", Arial, "Helvetica Neue", sans-serif;
     िशत color: var(--text);
      min-height: 100svh;
      background: transparent;
    }
    body::before{
      content:"";
      position: fixed;
      inset: 0;
      z-index: -1;
      pointer-events:none;
      background:
        radial-gradient(1200px 800px at 50% -200px, rgba(80,130,255,.18), transparent 60%),
        linear-gradient(180deg, var(--bg0), var(--bg1) 40%, var(--bg0));
      transform: translateZ(0);
    }

    sl-dialog:not(:defined){ display:none !important; }
    sl-alert:not(:defined){ display:none !important; }
    sl-button:not(:defined){ visibility:hidden; }

    .app{
      max-width: var(--app-max);
      margin: 0 auto;
      padding: 18px var(--pad) 120px;
    }

    .header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 12px;
      margin: 6px 0 12px;
    }
    .header h1{
      margin: 0;
      font-size: 28px;
      letter-spacing: -.4px;
      font-weight: 900;
      line-height: 1.1;
    }

    .toast-wrap{
      position: sticky;
      top: 10px;
      z-index: 999;
      padding: 0 var(--pad);
    }
    .toast-wrap sl-alert{
      max-width: var(--app-max);
      margin: 0 auto;
      border-radius: 14px;
    }

    /* 고정 신호등(헤더 아래 1회) */
    .lights-bar{
      position: relative;
      height: 36px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.03);
      overflow: hidden;
      display:flex;
      align-items:center;
      justify-content:center;
      gap: 18px;
      margin: 8px 0 12px;
    }
    .lights-bar::before{
      content:"";
      position:absolute;
      inset:0;
      pointer-events:none;
      background: radial-gradient(600px 120px at 50% 0%, rgba(255,255,255,.06), transparent 60%);
      opacity:.9;
    }
    .light-dot{
      position: relative;
      width: 14px;
      height: 14px;
      border-radius: 999px;
      opacity: .62;
      filter: saturate(1.05);
    }
    .light-dot::after{
      content:"";
      position:absolute;
      inset:-14px;
      border-radius: 999px;
      filter: blur(10px);
      opacity: .55;
      background: radial-gradient(circle, rgba(255,255,255,.35), transparent 60%);
      mix-blend-mode: screen;
    }
    .light-dot.red{ background: rgba(var(--red), .92); box-shadow: 0 0 22px rgba(var(--red), .26), 0 0 46px rgba(var(--red), .12); }
    .light-dot.amb{ background: rgba(var(--amber), .92); box-shadow: 0 0 22px rgba(var(--amber), .22), 0 0 46px rgba(var(--amber), .10); }
    .light-dot.grn{ background: rgba(var(--green), .92); box-shadow: 0 0 22px rgba(var(--green), .22), 0 0 46px rgba(var(--green), .10); }

    .list{
      display:flex;
      flex-direction:column;
      gap: 14px;
      margin-top: 8px;
    }

    .empty{
      margin-top: 18px;
      padding: 18px;
      border: 1px dashed rgba(255,255,255,.16);
      border-radius: 16px;
      color: var(--muted);
      text-align:center;
      line-height: 1.6;
    }
    .empty b{ color: var(--text); }

    .track{
      position: relative;
      height: var(--track-h);
      border-radius: var(--radius);
      background: var(--track);
      border: 1px solid var(--line);
      overflow: hidden;
      -webkit-tap-highlight-color: transparent;
    }

    /* tint: 전체 채움 X */
    .tint{
      position:absolute;
      inset:0;
      opacity: 0;
      pointer-events:none;
      transition: opacity .10s linear;
    }
    .tint.left{
      background: radial-gradient(520px 220px at 0% 55%, rgba(255,90,90,.22), transparent 66%);
    }
    .tint.right{
      background: radial-gradient(520px 220px at 100% 55%, rgba(80,220,140,.22), transparent 66%);
    }
    .tint.ambL{
      background: radial-gradient(420px 190px at 0% 55%, rgba(255,170,70,.12), transparent 70%);
    }
    .tint.ambR{
      background: radial-gradient(420px 190px at 100% 55%, rgba(255,170,70,.12), transparent 70%);
    }

    .zone{
      position:absolute;
      top:0; bottom:0;
      z-index: 3;
      background: transparent;
    }
    .zone.left{ left:0; width:34%; }
    .zone.center{ left:33%; width:34%; }
    .zone.right{ right:0; width:34%; }

    .pill{
      position:absolute;
      top: 50%;
      /* ✅ left(px) 기반으로 center를 잡고, transform(-50%)는 “항상 중앙 정렬 텍스트” 유지용 */
      left: 50%;
      transform: translate(-50%, -50%);
      height: var(--pill-h);
      min-width: var(--pill-minw);
      width: var(--pill-minw);
      border-radius: var(--pill-radius);

      display:flex;
      align-items:center;
      justify-content:center;

      padding: 0 var(--pill-pad-x);
      user-select:none;
      -webkit-user-select:none;
      touch-action: manipulation;

      /* default look */
      background: rgba(230,235,245,var(--default-pill-alpha));
      border: var(--pill-bd) solid rgba(255,255,255,var(--default-pill-bd-alpha));

      will-change: left, width, background, border-color;
      transition:
        left var(--move-ms) cubic-bezier(.2,.9,.25,1),
        width 220ms ease,
        background 120ms linear,
        border-color 120ms linear;

      z-index: 4;
      overflow: hidden;

      pointer-events: none; /* ✅ pill 클릭 제거(영역 클릭만) */
    }

    .pill-text{
      display:block;
      width:100%;
      text-align:center;  /* ✅ 텍스트는 항상 중앙 정렬 */
      white-space: nowrap;
      overflow: visible;
      text-overflow: clip;
      font-weight: 900;
      letter-spacing: -.2px;
      color: rgba(255,255,255,.92);
      font-size: 15px;
      transition: opacity 120ms ease;
      pointer-events: none;
    }
    .pill.is-meaning .pill-text{
      font-weight: 600;
      color: rgba(255,255,255,.78);
      font-size: 14px;
    }

    .footer{
      position: fixed;
      left:0; right:0; bottom:0;
      padding: 12px var(--pad) calc(12px + env(safe-area-inset-bottom));
      background: linear-gradient(180deg, transparent, rgba(0,0,0,.35) 25%, rgba(0,0,0,.55));
      backdrop-filter: blur(10px);
      z-index: 50;

      opacity: 0;
      transform: translateY(8px);
      pointer-events:none;
      transition: opacity .18s ease, transform .18s ease;
    }
    html.ready .footer{
      opacity: 1;
      transform: translateY(0);
      pointer-events:auto;
    }
    .footer-inner{
      max-width: var(--app-max);
      margin: 0 auto;
    }

    sl-dialog::part(panel){
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(20,24,32,.96);
      color: var(--text);
    }
    sl-dialog::part(title){
      font-weight: 900;
      letter-spacing: -.2px;
    }
    sl-button::part(base){ border-radius: 14px; }

    .charge-msg{
      font-size: 14px;
      color: rgba(255,255,255,.86);
      line-height: 1.5;
      margin-bottom: 10px;
    }
    .charge-remain{
      font-size: 12px;
      color: var(--muted);
      margin-bottom: 14px;
    }
    .btn-row{ display:flex; gap: 10px; }
    .btn-row sl-button{ flex: 1 1 0; }
    .btn-row sl-button::part(base){ width: 100%; }

    .measure{
      position:absolute;
      left:-9999px;
      top:-9999px;
      visibility:hidden;
      white-space:nowrap;
      letter-spacing:-.2px;
    }
  </style>
</head>

<body>
  <div class="toast-wrap" aria-live="polite" aria-atomic="true">
    <sl-alert id="toast" variant="primary" duration="2200" closable>
      <sl-icon slot="icon" name="info-circle"></sl-icon>
      <span id="toastText">안내</span>
    </sl-alert>
  </div>

  <main class="app">
    <div class="header">
      <h1>오늘의 단어</h1>
      <sl-button id="btnCharge" variant="primary">충전하기</sl-button>
    </div>

    <div class="lights-bar" aria-label="신호등">
      <span class="light-dot red" aria-hidden="true"></span>
      <span class="light-dot amb" aria-hidden="true"></span>
      <span class="light-dot grn" aria-hidden="true"></span>
    </div>

    <div id="emptyState" class="empty" style="display:none;">
      아직 오늘의 단어가 <b>0개</b>예요.<br>
      상단의 <b>충전하기</b>로 10개씩 추가해 주세요.
    </div>

    <div id="list" class="list"></div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      <sl-button id="ctaSubmit" variant="neutral" outline disabled style="width:100%;">제출하기 (Phase 2~)</sl-button>
    </div>
  </footer>

  <sl-dialog id="dlgCharge" label="충전하기">
    <div class="charge-msg">한 번에 10개씩 충전이 가능해요</div>
    <div class="charge-remain">오늘 남은 횟수 <b id="remainText">3/3</b></div>

    <div class="btn-row">
      <sl-button id="dlgChargeDo" variant="primary">충전하기</sl-button>
      <sl-button id="dlgChargeClose" variant="default" outline>닫기</sl-button>
    </div>
  </sl-dialog>

  <span id="measurer" class="measure"></span>

  <script>
  /* =========================================================
    Rebuild v1.1
    - ✅ anchor 기반(width 변화 시 트랙 밖으로 안 나가게)
    - ✅ 잔상/튐 제거(토큰으로 이전 애니/타이머 무효화)
    - ✅ pill 클릭 없음(영역 클릭만)
  ========================================================= */

  const LS_KEY = "signal_vocab_rebuild_v1_1";
  const todayKey = (() => {
    const d = new Date();
    const y = d.getFullYear();
    const m = String(d.getMonth() + 1).padStart(2, "0");
    const day = String(d.getDate()).padStart(2, "0");
    return `${y}-${m}-${day}`;
  })();

  function loadState(){
    try{
      const raw = localStorage.getItem(LS_KEY);
      if(!raw) return { day: todayKey, chargeUsed: 0, words: [] };
      const s = JSON.parse(raw);
      if(s.day !== todayKey) return { day: todayKey, chargeUsed: 0, words: [] };
      return {
        day: s.day || todayKey,
        chargeUsed: Number(s.chargeUsed || 0),
        words: Array.isArray(s.words) ? s.words : []
      };
    }catch(e){
      return { day: todayKey, chargeUsed: 0, words: [] };
    }
  }
  function saveState(state){
    localStorage.setItem(LS_KEY, JSON.stringify(state));
  }

  function makeDummyWords(n){
    const pool = [
      ["abandon", "버리다, 포기하다"],
      ["accurate", "정확한"],
      ["benevolent", "자비로운, 선의의"],
      ["consequence", "결과, 영향"],
      ["diligent", "성실한"],
      ["elaborate", "정교한, 상세히 설명하다"],
      ["friction", "마찰, 충돌"],
      ["gratitude", "감사"],
      ["hesitate", "망설이다"],
      ["inevitable", "피할 수 없는"]
    ];
    const out = [];
    const base = Date.now().toString(36);
    for(let i=0;i<n;i++){
      const pick = pool[Math.floor(Math.random()*pool.length)];
      out.push({
        id: `${base}-${i}-${Math.random().toString(16).slice(2,8)}`,
        word: pick[0],
        meaning: pick[1],
        status: "default", // default | red | yellow | green
        touched: false
      });
    }
    return out;
  }

  const toast = document.getElementById("toast");
  const toastText = document.getElementById("toastText");
  function showToast(msg){ toastText.textContent = msg; toast.toast(); }

  const btnCharge = document.getElementById("btnCharge");
  const dlgCharge = document.getElementById("dlgCharge");
  const dlgChargeDo = document.getElementById("dlgChargeDo");
  const dlgChargeClose = document.getElementById("dlgChargeClose");
  const remainText = document.getElementById("remainText");

  const listEl = document.getElementById("list");
  const emptyState = document.getElementById("emptyState");
  const measurer = document.getElementById("measurer");

  function escapeHtml(s){
    return String(s)
      .replaceAll("&", "&amp;")
      .replaceAll("<", "&lt;")
      .replaceAll(">", "&gt;")
      .replaceAll('"', "&quot;")
      .replaceAll("'", "&#039;");
  }

  const RGB_RED   = [255, 90, 90];
  const RGB_AMBER = [255, 170, 70];
  const RGB_GREEN = [80, 220, 140];

  function clamp01(x){ return Math.max(0, Math.min(1, x)); }
  function lerp(a,b,t){ return a + (b-a)*t; }
  function easeInOutCubic(t){
    t = clamp01(t);
    return t < 0.5 ? 4*t*t*t : 1 - Math.pow(-2*t + 2, 3) / 2;
  }
  function mix3(p){
    let rgb;
    if(p <= 0.5){
      const t = p / 0.5;
      rgb = [
        Math.round(lerp(RGB_RED[0], RGB_AMBER[0], t)),
        Math.round(lerp(RGB_RED[1], RGB_AMBER[1], t)),
        Math.round(lerp(RGB_RED[2], RGB_AMBER[2], t))
      ];
    }else{
      const t = (p - 0.5) / 0.5;
      rgb = [
        Math.round(lerp(RGB_AMBER[0], RGB_GREEN[0], t)),
        Math.round(lerp(RGB_AMBER[1], RGB_GREEN[1], t)),
        Math.round(lerp(RGB_AMBER[2], RGB_GREEN[2], t))
      ];
    }
    return rgb;
  }

  function getCSSNum(varName, fallback){
    const v = getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
    const n = parseFloat(v);
    return Number.isFinite(n) ? n : fallback;
  }

  function measureTextPx(text, isMeaning){
    measurer.style.fontSize = isMeaning ? "14px" : "15px";
    measurer.style.fontWeight = isMeaning ? "600" : "900";
    measurer.textContent = text || "";
    return Math.ceil(measurer.getBoundingClientRect().width);
  }

  function setPillWidthToText(pillEl, text, isMeaning){
    const minW = getCSSNum("--pill-minw", 140);
    const padX = getCSSNum("--pill-pad-x", 14);
    const bd = getCSSNum("--pill-bd", 1);
    const tW = measureTextPx(text, isMeaning);
    const w = Math.max(minW, tW + (padX*2) + (bd*2) + 6);
    pillEl.style.width = w + "px";
    return w;
  }

  function buildTrackRow(wordObj, state){
    const el = document.createElement("div");
    el.className = "track";
    el.dataset.id = wordObj.id;

    el.innerHTML = `
      <div class="tint left"></div>
      <div class="tint right"></div>
      <div class="tint ambL"></div>
      <div class="tint ambR"></div>

      <div class="zone left" aria-label="왼쪽(RED)"></div>
      <div class="zone center" aria-label="가운데(YELLOW)"></div>
      <div class="zone right" aria-label="오른쪽(GREEN)"></div>

      <div class="pill" aria-hidden="true">
        <span class="pill-text">${escapeHtml(wordObj.word)}</span>
      </div>
    `;

    const tintL  = el.querySelector(".tint.left");
    const tintR  = el.querySelector(".tint.right");
    const tintAL = el.querySelector(".tint.ambL");
    const tintAR = el.querySelector(".tint.ambR");

    const zoneL  = el.querySelector(".zone.left");
    const zoneC  = el.querySelector(".zone.center");
    const zoneR  = el.querySelector(".zone.right");

    const pill   = el.querySelector(".pill");
    const txt    = el.querySelector(".pill-text");

    // =========================
    // Row-local tokens (✅ 잔상 제거 핵심)
    // =========================
    let peekToken = 0;
    let moveToken = 0;

    // 상태별 anchor
    // red => left, yellow => center, green => right
    function statusToAnchor(st){
      if(st === "red") return "left";
      if(st === "green") return "right";
      return "center"; // yellow/default
    }
    function statusToP(st){
      if(st === "red") return 0;
      if(st === "green") return 1;
      if(st === "yellow") return 0.5;
      return 0.5; // default도 중앙
    }

    // 현재 진행 상태
    let curP = statusToP(wordObj.status || "default");

    function applyContinuousVisual(p){
      const rgb = mix3(p);
      pill.style.background = `rgba(${rgb[0]},${rgb[1]},${rgb[2]},0.30)`;
      pill.style.borderColor = `rgba(${rgb[0]},${rgb[1]},${rgb[2]},0.32)`;

      const redI = clamp01((0.5 - p) / 0.5);
      const greenI = clamp01((p - 0.5) / 0.5);
      const yellowI = 1 - clamp01(Math.abs(p - 0.5) / 0.5);

      tintL.style.opacity  = String(Math.min(1, redI * 0.85));
      tintR.style.opacity  = String(Math.min(1, greenI * 0.85));
      tintAL.style.opacity = String(Math.min(1, yellowI * 0.55));
      tintAR.style.opacity = String(Math.min(1, yellowI * 0.55));
    }

    function setDefaultVisual(){
      pill.style.background = "";
      pill.style.borderColor = "";
      tintL.style.opacity = "0";
      tintR.style.opacity = "0";
      tintAL.style.opacity = "0";
      tintAR.style.opacity = "0";
    }

    // ✅ anchor 기반 centerX 계산
    // - left: left edge 고정 => centerX = pad + width/2
    // - right: right edge 고정 => centerX = trackW - pad - width/2
    // - center: centerX = trackW/2
    function computeCenterX(anchor, pillW){
      const trackW = el.getBoundingClientRect().width;
      const pad = getCSSNum("--edge-pad", 10);

      if(anchor === "left"){
        return pad + pillW/2;
      }
      if(anchor === "right"){
        return trackW - pad - pillW/2;
      }
      return trackW/2;
    }

    function setPillLeftByAnchor(anchor){
      const pillW = pill.getBoundingClientRect().width || getCSSNum("--pill-minw", 140);
      const cx = computeCenterX(anchor, pillW);
      pill.style.left = cx + "px";
    }

    // ✅ “상태/너비가 바뀔 때” 항상 anchor 기준으로 left를 재계산
    function syncPositionForCurrentState(){
      const st = wordObj.status || "default";
      const anchor = statusToAnchor(st === "default" ? "yellow" : st);
      setPillLeftByAnchor(anchor);
    }

    // ✅ 이동 애니메이션 (rAF) + 토큰으로 이전 애니 무효화
    function moveToStatus(nextStatus){
      const token = ++moveToken;

      // default는 이동만(센터) 하고 비주얼은 default로
      const fromP = curP;
      const toP = statusToP(nextStatus);
      const moveMs = getCSSNum("--move-ms", 360);

      const t0 = performance.now();

      function step(now){
        if(token !== moveToken) return; // ✅ 이전 move 무효
        const t = clamp01((now - t0)/moveMs);
        const e = easeInOutCubic(t);
        const p = lerp(fromP, toP, e);

        curP = p;

        // 비주얼
        if(nextStatus === "default"){
          // default는 연속 비주얼 X
          setDefaultVisual();
        }else{
          applyContinuousVisual(p);
        }

        // 위치: anchor 기반
        const anchor = statusToAnchor(nextStatus === "default" ? "yellow" : nextStatus);
        const pillW = pill.getBoundingClientRect().width || getCSSNum("--pill-minw", 140);
        const cx = computeCenterX(anchor, pillW);
        pill.style.left = cx + "px";

        if(t < 1){
          requestAnimationFrame(step);
        }else{
          // 끝난 뒤, 혹시 너비가 변했을 수 있으니 최종 싱크
          syncPositionForCurrentState();
          if(nextStatus !== "default") applyContinuousVisual(curP);
        }
      }

      requestAnimationFrame(step);
    }

    // ✅ peek: 단어→뜻→단어
    function startPeek(){
      const token = ++peekToken;

      const inMs   = getCSSNum("--peek-in-ms", 120);
      const holdMs = getCSSNum("--peek-hold-ms", 560);
      const outMs  = getCSSNum("--peek-out-ms", 200);

      const word = wordObj.word || "";
      const meaning = wordObj.meaning || "";

      // step0: 현재 상태 anchor
      const st = wordObj.status || "default";
      const anchor = statusToAnchor(st === "default" ? "yellow" : st);

      // fade out
      txt.style.opacity = "0";

      setTimeout(()=>{
        if(token !== peekToken) return; // ✅ 이전 peek 무효

        pill.classList.add("is-meaning");
        txt.textContent = meaning;

        // ✅ width 변경
        setPillWidthToText(pill, meaning, true);
        // ✅ width 변경 후 anchor 기준으로 left 재계산 (여기가 핵심!)
        setPillLeftByAnchor(anchor);

        txt.style.opacity = "1";

        setTimeout(()=>{
          if(token !== peekToken) return;

          txt.style.opacity = "0";

          setTimeout(()=>{
            if(token !== peekToken) return;

            pill.classList.remove("is-meaning");
            txt.textContent = word;

            // ✅ word width 복원
            setPillWidthToText(pill, word, false);
            // ✅ 복원 시에도 anchor 기준으로 left 재계산 (여기가 핵심!)
            setPillLeftByAnchor(anchor);

            txt.style.opacity = "1";
          }, outMs);

        }, holdMs);

      }, inMs);
    }

    function commitStatus(nextStatus){
      const idx = state.words.findIndex(w => w.id === wordObj.id);
      if(idx < 0) return;

      const prev = state.words[idx].status || "default";

      // ✅ 첫 터치 순간 default 종료
      if(prev === "default"){
        state.words[idx].touched = true;
      }

      // ✅ 한 번이라도 touched면 default로 돌아갈 수 없음
      if(state.words[idx].touched && nextStatus === "default"){
        nextStatus = "yellow";
      }

      state.words[idx].status = nextStatus;
      saveState(state);

      // 로컬 오브젝트도 동기화
      wordObj.status = nextStatus;
      wordObj.touched = !!state.words[idx].touched;
    }

    function hardResetEffects(){
      // ✅ 새로운 클릭 들어오면 이전 모든 타임라인 무효화
      peekToken++;
      moveToken++;

      // 텍스트/클래스 강제 복구
      pill.classList.remove("is-meaning");
      txt.textContent = wordObj.word || "";
      txt.style.opacity = "1";

      // width를 word 기준으로 먼저 복구하고(안전), 현재 상태 anchor로 즉시 정렬
      setPillWidthToText(pill, wordObj.word || "", false);
      syncPositionForCurrentState();

      // 비주얼은 status에 따라
      const st = wordObj.status || "default";
      if(st === "default") setDefaultVisual();
      else applyContinuousVisual(curP);
    }

    function onZoneClick(nextStatus){
      // ✅ 잔상 제거: 먼저 이전 진행 중인 것 전부 정리
      hardResetEffects();

      // 상태 저장
      commitStatus(nextStatus);

      // 이동 + 비주얼
      moveToStatus(nextStatus);

      // 의미 peek (이동과 동시에 시작 가능)
      startPeek();
    }

    // 이벤트: 영역 클릭만
    zoneL.addEventListener("click", (e)=>{ e.stopPropagation(); onZoneClick("red"); });
    zoneC.addEventListener("click", (e)=>{ e.stopPropagation(); onZoneClick("yellow"); });
    zoneR.addEventListener("click", (e)=>{ e.stopPropagation(); onZoneClick("green"); });

    // 초기: word width 세팅 + 상태 반영
    requestAnimationFrame(()=>{
      setPillWidthToText(pill, wordObj.word || "", false);
      syncPositionForCurrentState();

      const st = wordObj.status || "default";
      curP = statusToP(st);

      if(st === "default"){
        setDefaultVisual(); // ✅ 초기 노란 잔상 방지
      }else{
        applyContinuousVisual(curP);
      }
    });

    // 리사이즈: anchor 기준으로 재정렬
    let rt = null;
    window.addEventListener("resize", ()=>{
      clearTimeout(rt);
      rt = setTimeout(()=>{
        syncPositionForCurrentState();
      }, 80);
    }, { passive:true });

    return el;
  }

  let state = loadState();

  function render(){
    listEl.innerHTML = "";
    const count = state.words.length;

    const remain = Math.max(0, 3 - state.chargeUsed);
    remainText.textContent = `${remain}/3`;
    btnCharge.disabled = remain <= 0;

    if(count === 0){
      emptyState.style.display = "block";
      return;
    }
    emptyState.style.display = "none";

    for(const w of state.words){
      listEl.appendChild(buildTrackRow(w, state));
    }
  }

  // Charge modal
  btnCharge.addEventListener("click", ()=>{
    state = loadState();
    const remain = Math.max(0, 3 - state.chargeUsed);
    remainText.textContent = `${remain}/3`;
    dlgChargeDo.disabled = remain <= 0;
    dlgCharge.show();
  });
  dlgChargeClose.addEventListener("click", ()=> dlgCharge.hide());

  dlgChargeDo.addEventListener("click", ()=>{
    state = loadState();
    const remain = 3 - state.chargeUsed;
    if(remain <= 0){
      dlgCharge.hide();
      showToast("오늘 충전은 3회까지예요.");
      return;
    }
    state.words = state.words.concat(makeDummyWords(10));
    state.chargeUsed += 1;
    saveState(state);
    dlgCharge.hide();
    render();
    showToast(`충전 완료! +10개 (남은 ${Math.max(0, 3 - state.chargeUsed)}/3)`);
  });

  render();
  requestAnimationFrame(()=> document.documentElement.classList.add("ready"));
  </script>
</body>
</html>
