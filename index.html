<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>신호등보카 (Rebuild)</title>

  <!-- Shoelace (CDN) -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.15.0/cdn/themes/light.css">
  <script type="module" src="https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.15.0/cdn/shoelace.js"></script>

  <style>
    :root{
      --app-max: 520px;

      /* timings */
      --move-ms: 360ms;
      --peek-in-ms: 200ms;
      --peek-hold-ms: 2500ms;
      --peek-out-ms: 200ms;

      /* Theme */
      --bg0: #070a10;
      --bg1: #0b0f14;

      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.58);

      --track: rgba(255,255,255,.06);
      --line: rgba(255,255,255,.10);

      --radius: 18px;
      --pill-radius: 999px;

      --track-h: 72px;

      /* pill */
      --pill-h: 44px;
      --pill-minw: 140px;
      --pill-pad-x: 14px;
      --pill-bd: 1px;

      --pad: 12px;

      /* Lights */
      --red:   255, 90,  90;
      --green:  80, 220, 140;
      --amber: 255, 170,  70;

      /* default pill (처음) */
      --default-pill-alpha: .18;
      --default-pill-bd-alpha: .12;
    }

    *{ box-sizing:border-box; }
    html{ background: var(--bg0); }
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Apple SD Gothic Neo", "Noto Sans KR", Arial, "Helvetica Neue", sans-serif;
      color: var(--text);
      min-height: 100svh;
      background: transparent;
    }
    body::before{
      content:"";
      position: fixed;
      inset: 0;
      z-index: -1;
      pointer-events:none;
      background:
        radial-gradient(1200px 800px at 50% -200px, rgba(80,130,255,.18), transparent 60%),
        linear-gradient(180deg, var(--bg0), var(--bg1) 40%, var(--bg0));
      transform: translateZ(0);
    }

    sl-dialog:not(:defined){ display:none !important; }
    sl-alert:not(:defined){ display:none !important; }
    sl-button:not(:defined){ visibility:hidden; }

    .app{
      max-width: var(--app-max);
      margin: 0 auto;
      padding: 18px var(--pad) 120px;
    }

    .header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 12px;
      margin: 6px 0 12px;
    }
    .header h1{
      margin: 0;
      font-size: 28px;
      letter-spacing: -.4px;
      font-weight: 900;
      line-height: 1.1;
    }

    .toast-wrap{
      position: sticky;
      top: 10px;
      z-index: 999;
      padding: 0 var(--pad);
    }
    .toast-wrap sl-alert{
      max-width: var(--app-max);
      margin: 0 auto;
      border-radius: 14px;
    }

    /* 고정 신호등(헤더 아래 1회) */
    .lights-bar{
      position: relative;
      height: 36px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.03);
      overflow: hidden;
      display:flex;
      align-items:center;
      justify-content:center;
      gap: 18px;
      margin: 8px 0 12px;
    }
    .lights-bar::before{
      content:"";
      position:absolute;
      inset:0;
      pointer-events:none;
      background: radial-gradient(600px 120px at 50% 0%, rgba(255,255,255,.06), transparent 60%);
      opacity:.9;
    }
    .light-dot{
      position: relative;
      width: 14px;
      height: 14px;
      border-radius: 999px;
      opacity: .62;
      filter: saturate(1.05);
    }
    .light-dot::after{
      content:"";
      position:absolute;
      inset:-14px;
      border-radius: 999px;
      filter: blur(10px);
      opacity: .55;
      background: radial-gradient(circle, rgba(255,255,255,.35), transparent 60%);
      mix-blend-mode: screen;
    }
    .light-dot.red{ background: rgba(var(--red), .92); box-shadow: 0 0 22px rgba(var(--red), .26), 0 0 46px rgba(var(--red), .12); }
    .light-dot.amb{ background: rgba(var(--amber), .92); box-shadow: 0 0 22px rgba(var(--amber), .22), 0 0 46px rgba(var(--amber), .10); }
    .light-dot.grn{ background: rgba(var(--green), .92); box-shadow: 0 0 22px rgba(var(--green), .22), 0 0 46px rgba(var(--green), .10); }

    .list{
      display:flex;
      flex-direction:column;
      gap: 14px;
      margin-top: 8px;
    }

    .empty{
      margin-top: 18px;
      padding: 18px;
      border: 1px dashed rgba(255,255,255,.16);
      border-radius: 16px;
      color: var(--muted);
      text-align:center;
      line-height: 1.6;
    }
    .empty b{ color: var(--text); }

    .track{
      position: relative;
      height: var(--track-h);
      border-radius: var(--radius);
      background: var(--track);
      border: 1px solid var(--line);
      overflow: hidden;
      -webkit-tap-highlight-color: transparent;
    }

    /* tint: 전체 채움 X */
    .tint{
      position:absolute;
      inset:0;
      opacity: 0;
      pointer-events:none;
      transition: opacity .10s linear;
    }
    .tint.left{
      background: radial-gradient(520px 220px at 0% 55%, rgba(255,90,90,.22), transparent 66%);
    }
    .tint.right{
      background: radial-gradient(520px 220px at 100% 55%, rgba(80,220,140,.22), transparent 66%);
    }
    .tint.ambL{
      background: radial-gradient(420px 190px at 0% 55%, rgba(255,170,70,.12), transparent 70%);
    }
    .tint.ambR{
      background: radial-gradient(420px 190px at 100% 55%, rgba(255,170,70,.12), transparent 70%);
    }

    .zone{
      position:absolute;
      top:0; bottom:0;
      z-index: 3;
      background: transparent;
    }
    .zone.left{ left:0; width:34%; }
    .zone.center{ left:33%; width:34%; }
    .zone.right{ right:0; width:34%; }

    .pill{
      position:absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) translateX(0px);
      height: var(--pill-h);
      min-width: var(--pill-minw);
      width: var(--pill-minw);

      border-radius: var(--pill-radius);
      display:flex;
      align-items:center;
      justify-content:center;

      padding: 0 var(--pill-pad-x);
      user-select:none;
      -webkit-user-select:none;
      touch-action: manipulation;

      /* default look */
      background: rgba(230,235,245,var(--default-pill-alpha));
      border: var(--pill-bd) solid rgba(255,255,255,var(--default-pill-bd-alpha));

      will-change: transform, width, background, border-color;
      transition:
        transform var(--move-ms) cubic-bezier(.2,.9,.25,1),
        width 220ms ease,
        background 120ms linear,
        border-color 120ms linear;

      z-index: 4;
      overflow: hidden;
      pointer-events: none; /* ✅ pill 자체 클릭 제거: 영역 클릭만 */
    }

    .pill-text{
      display:block;
      width:100%;
      text-align:center;
      white-space: nowrap;
      overflow: visible;
      text-overflow: clip;
      font-weight: 900;
      letter-spacing: -.2px;
      color: rgba(255,255,255,.92);
      font-size: 15px;
      transition: opacity 120ms ease;
      pointer-events: none;
    }
    .pill.is-meaning .pill-text{
      font-weight: 600;
      color: rgba(255,255,255,.78);
      font-size: 14px;
    }

    .footer{
      position: fixed;
      left:0; right:0; bottom:0;
      padding: 12px var(--pad) calc(12px + env(safe-area-inset-bottom));
      background: linear-gradient(180deg, transparent, rgba(0,0,0,.35) 25%, rgba(0,0,0,.55));
      backdrop-filter: blur(10px);
      z-index: 50;

      opacity: 0;
      transform: translateY(8px);
      pointer-events:none;
      transition: opacity .18s ease, transform .18s ease;
    }
    html.ready .footer{
      opacity: 1;
      transform: translateY(0);
      pointer-events:auto;
    }
    .footer-inner{
      max-width: var(--app-max);
      margin: 0 auto;
    }

    sl-dialog::part(panel){
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(20,24,32,.96);
      color: var(--text);
    }
    sl-dialog::part(title){
      font-weight: 900;
      letter-spacing: -.2px;
    }
    sl-button::part(base){ border-radius: 14px; }

    .charge-msg{
      font-size: 14px;
      color: rgba(255,255,255,.86);
      line-height: 1.5;
      margin-bottom: 10px;
    }
    .charge-remain{
      font-size: 12px;
      color: var(--muted);
      margin-bottom: 14px;
    }
    .btn-row{ display:flex; gap: 10px; }
    .btn-row sl-button{ flex: 1 1 0; }
    .btn-row sl-button::part(base){ width: 100%; }

    .measure{
      position:absolute;
      left:-9999px;
      top:-9999px;
      visibility:hidden;
      white-space:nowrap;
      letter-spacing:-.2px;
    }
  </style>
</head>

<body>
  <div class="toast-wrap" aria-live="polite" aria-atomic="true">
    <sl-alert id="toast" variant="primary" duration="2200" closable>
      <sl-icon slot="icon" name="info-circle"></sl-icon>
      <span id="toastText">안내</span>
    </sl-alert>
  </div>

  <main class="app">
    <div class="header">
      <h1>오늘의 단어</h1>
      <sl-button id="btnCharge" variant="primary">충전하기</sl-button>
    </div>

    <div class="lights-bar" aria-label="신호등">
      <span class="light-dot red" aria-hidden="true"></span>
      <span class="light-dot amb" aria-hidden="true"></span>
      <span class="light-dot grn" aria-hidden="true"></span>
    </div>

    <div id="emptyState" class="empty" style="display:none;">
      아직 오늘의 단어가 <b>0개</b>예요.<br>
      상단의 <b>충전하기</b>로 10개씩 추가해 주세요.
    </div>

    <div id="list" class="list"></div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      <sl-button id="ctaSubmit" variant="neutral" outline disabled style="width:100%;">제출하기 (Phase 2~)</sl-button>
    </div>
  </footer>

  <sl-dialog id="dlgCharge" label="충전하기">
    <div class="charge-msg">한 번에 10개씩 충전이 가능해요</div>
    <div class="charge-remain">오늘 남은 횟수 <b id="remainText">3/3</b></div>

    <div class="btn-row">
      <sl-button id="dlgChargeDo" variant="primary">충전하기</sl-button>
      <sl-button id="dlgChargeClose" variant="default" outline>닫기</sl-button>
    </div>
  </sl-dialog>

  <span id="measurer" class="measure"></span>

  <script>
  const LS_KEY = "signal_vocab_rebuild_v0";
  const todayKey = (() => {
    const d = new Date();
    const y = d.getFullYear();
    const m = String(d.getMonth() + 1).padStart(2, "0");
    const day = String(d.getDate()).padStart(2, "0");
    return `${y}-${m}-${day}`;
  })();

  function loadState(){
    try{
      const raw = localStorage.getItem(LS_KEY);
      if(!raw) return { day: todayKey, chargeUsed: 0, words: [] };
      const s = JSON.parse(raw);
      if(s.day !== todayKey) return { day: todayKey, chargeUsed: 0, words: [] };
      return {
        day: s.day || todayKey,
        chargeUsed: Number(s.chargeUsed || 0),
        words: Array.isArray(s.words) ? s.words : []
      };
    }catch(e){
      return { day: todayKey, chargeUsed: 0, words: [] };
    }
  }
  function saveState(state){
    localStorage.setItem(LS_KEY, JSON.stringify(state));
  }

  function makeDummyWords(n){
    const pool = [
      ["abandon", "버리다, 포기하다"],
      ["accurate", "정확한"],
      ["benevolent", "자비로운, 선의의"],
      ["consequencedfdfdffdf", "결과, 영향"],
      ["diligent", "성실한"],
      ["elaborate", "정교한, 상세히 설명하다, ㅇㄹㅇㄹㅇㄹㅇㄹㅇㄹㅇ"],
      ["friction", "마찰, 충돌"],
      ["gratitude", "감사"],
      ["hesitate", "망설이다"],
      ["inevitable", "피할 수 없는"]
    ];
    const out = [];
    const base = Date.now().toString(36);
    for(let i=0;i<n;i++){
      const pick = pool[Math.floor(Math.random()*pool.length)];
      out.push({
        id: `${base}-${i}-${Math.random().toString(16).slice(2,8)}`,
        word: pick[0],
        meaning: pick[1],
        status: "default",
        touched: false
      });
    }
    return out;
  }

  const toast = document.getElementById("toast");
  const toastText = document.getElementById("toastText");
  function showToast(msg){ toastText.textContent = msg; toast.toast(); }

  const btnCharge = document.getElementById("btnCharge");
  const dlgCharge = document.getElementById("dlgCharge");
  const dlgChargeDo = document.getElementById("dlgChargeDo");
  const dlgChargeClose = document.getElementById("dlgChargeClose");
  const remainText = document.getElementById("remainText");

  const listEl = document.getElementById("list");
  const emptyState = document.getElementById("emptyState");
  const measurer = document.getElementById("measurer");

  function escapeHtml(s){
    return String(s)
      .replaceAll("&", "&amp;")
      .replaceAll("<", "&lt;")
      .replaceAll(">", "&gt;")
      .replaceAll('"', "&quot;")
      .replaceAll("'", "&#039;");
  }

  const RGB_RED   = [255, 90, 90];
  const RGB_AMBER = [255, 170, 70];
  const RGB_GREEN = [80, 220, 140];

  function clamp01(x){ return Math.max(0, Math.min(1, x)); }
  function lerp(a,b,t){ return a + (b-a)*t; }
  function easeInOutCubic(t){
    t = clamp01(t);
    return t < 0.5 ? 4*t*t*t : 1 - Math.pow(-2*t + 2, 3) / 2;
  }
  function mix3(p){
    let rgb;
    if(p <= 0.5){
      const t = p / 0.5;
      rgb = [
        Math.round(lerp(RGB_RED[0], RGB_AMBER[0], t)),
        Math.round(lerp(RGB_RED[1], RGB_AMBER[1], t)),
        Math.round(lerp(RGB_RED[2], RGB_AMBER[2], t))
      ];
    }else{
      const t = (p - 0.5) / 0.5;
      rgb = [
        Math.round(lerp(RGB_AMBER[0], RGB_GREEN[0], t)),
        Math.round(lerp(RGB_AMBER[1], RGB_GREEN[1], t)),
        Math.round(lerp(RGB_AMBER[2], RGB_GREEN[2], t))
      ];
    }
    return rgb;
  }

  function measureTextPx(text, isMeaning){
    measurer.style.fontSize = isMeaning ? "14px" : "15px";
    measurer.style.fontWeight = isMeaning ? "600" : "900";
    measurer.textContent = text || "";
    return Math.ceil(measurer.getBoundingClientRect().width);
  }

  function setPillWidthToText(pillEl, text, isMeaning){
    const minW = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--pill-minw")) || 140;
    const padX = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--pill-pad-x")) || 14;
    const bd = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--pill-bd")) || 1;
    const tW = measureTextPx(text, isMeaning);
    const w = Math.max(minW, tW + (padX*2) + (bd*2) + 6);
    pillEl.style.width = w + "px";
  }

  function buildTrackRow(wordObj, state){
    const el = document.createElement("div");
    el.className = "track";
    el.dataset.id = wordObj.id;

    el.innerHTML = `
      <div class="tint left"></div>
      <div class="tint right"></div>
      <div class="tint ambL"></div>
      <div class="tint ambR"></div>

      <div class="zone left" aria-label="왼쪽(RED)"></div>
      <div class="zone center" aria-label="가운데(YELLOW)"></div>
      <div class="zone right" aria-label="오른쪽(GREEN)"></div>

      <div class="pill" aria-hidden="true">
        <span class="pill-text">${escapeHtml(wordObj.word)}</span>
      </div>
    `;

    const tintL  = el.querySelector(".tint.left");
    const tintR  = el.querySelector(".tint.right");
    const tintAL = el.querySelector(".tint.ambL");
    const tintAR = el.querySelector(".tint.ambR");

    const zoneL  = el.querySelector(".zone.left");
    const zoneC  = el.querySelector(".zone.center");
    const zoneR  = el.querySelector(".zone.right");

    const pill   = el.querySelector(".pill");
    const txt    = el.querySelector(".pill-text");

    setPillWidthToText(pill, wordObj.word || "", false);

    let curP = 0.5;
    let moving = false;

    let peekToken = 0;

    function statusToP(status){
      if(status === "red") return 0;
      if(status === "green") return 1;
      if(status === "yellow") return 0.5;
      return 0.5; // default
    }

    function pToX(p){
      const trackW = el.getBoundingClientRect().width;
      const pillW = pill.getBoundingClientRect().width;
      const pad = 10;
      const half = trackW/2;
      const halfP = pillW/2;
      const minX = -(half - halfP - pad);
      const maxX = +(half - halfP - pad);
      const x = lerp(minX, maxX, p);
      return { x };
    }

    function applyContinuousVisual(p){
      const rgb = mix3(p);
      pill.style.background = `rgba(${rgb[0]},${rgb[1]},${rgb[2]},0.30)`;
      pill.style.borderColor = `rgba(${rgb[0]},${rgb[1]},${rgb[2]},0.32)`;

      const redI = clamp01((0.5 - p) / 0.5);
      const greenI = clamp01((p - 0.5) / 0.5);
      const yellowI = 1 - clamp01(Math.abs(p - 0.5) / 0.5);

      tintL.style.opacity  = String(Math.min(1, redI * 0.85));
      tintR.style.opacity  = String(Math.min(1, greenI * 0.85));
      tintAL.style.opacity = String(Math.min(1, yellowI * 0.55));
      tintAR.style.opacity = String(Math.min(1, yellowI * 0.55));
    }

    function setDefaultVisual(){
      pill.style.background = "";
      pill.style.borderColor = "";
      tintL.style.opacity = "0";
      tintR.style.opacity = "0";
      tintAL.style.opacity = "0";
      tintAR.style.opacity = "0";
    }

    function setPillTransformByP(p){
      const { x } = pToX(p);
      pill.style.transform = `translate(-50%, -50%) translateX(${x}px)`;
    }

    function moveToP(nextP, animate){
      if(!animate){
        pill.style.transition = "none";
        setPillTransformByP(nextP);
        pill.offsetHeight;
        pill.style.transition = "";
        curP = nextP;
        return;
      }

      moving = true;
      const moveMs = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--move-ms")) || 360;
      const t0 = performance.now();
      const fromP = curP;
      const toP = nextP;

      function step(now){
        const t = clamp01((now - t0)/moveMs);
        const e = easeInOutCubic(t);
        const p = lerp(fromP, toP, e);

        setPillTransformByP(p);
        applyContinuousVisual(p);

        if(t < 1){
          requestAnimationFrame(step);
        }else{
          curP = toP;
          moving = false;
          applyContinuousVisual(curP);
        }
      }
      requestAnimationFrame(step);
    }

    function commitStatus(nextStatus){
      const idx = state.words.findIndex(w => w.id === wordObj.id);
      if(idx < 0) return;

      const prev = state.words[idx].status || "default";
      if(prev === "default") state.words[idx].touched = true;

      // touched 이후 default 금지
      if(state.words[idx].touched && nextStatus === "default"){
        nextStatus = "yellow";
      }

      state.words[idx].status = nextStatus;
      saveState(state);
    }

    function startPeek(){
      const token = ++peekToken;

      const inMs   = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--peek-in-ms")) || 120;
      const holdMs = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--peek-hold-ms")) || 560;
      const outMs  = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--peek-out-ms")) || 200;

      const word = wordObj.word || "";
      const meaning = wordObj.meaning || "";

      txt.style.opacity = "0";

      setTimeout(()=>{
        if(token !== peekToken) return;

        pill.classList.add("is-meaning");
        txt.textContent = meaning;
        setPillWidthToText(pill, meaning, true);
        txt.style.opacity = "1";

        // 폭 변경 후 현재 p 위치로 재정렬
        setPillTransformByP(curP);

        setTimeout(()=>{
          if(token !== peekToken) return;

          txt.style.opacity = "0";
          setTimeout(()=>{
            if(token !== peekToken) return;

            pill.classList.remove("is-meaning");
            txt.textContent = word;
            setPillWidthToText(pill, word, false);
            txt.style.opacity = "1";

            setPillTransformByP(curP);
          }, outMs);

        }, holdMs);

      }, inMs);
    }

    function onZone(status){
      // 상태 갱신
      wordObj.status = status;
      if(wordObj.status === "default") wordObj.touched = true;

      commitStatus(status);

      // 이동 + 비주얼
      if(status === "default"){
        setDefaultVisual();
        moveToP(0.5, true);
      }else{
        const p = statusToP(status);
        moveToP(p, true);
      }

      // meaning peek
      startPeek();
    }

    zoneL.addEventListener("click", (e)=>{ e.stopPropagation(); if(!moving) onZone("red"); else onZone("red"); });
    zoneC.addEventListener("click", (e)=>{ e.stopPropagation(); if(!moving) onZone("yellow"); else onZone("yellow"); });
    zoneR.addEventListener("click", (e)=>{ e.stopPropagation(); if(!moving) onZone("green"); else onZone("green"); });

    // 초기 상태 반영 (✅ default면 절대 연속 비주얼 호출 안 함)
    const initStatus = wordObj.status || "default";
    curP = statusToP(initStatus);

    requestAnimationFrame(()=>{
      setPillWidthToText(pill, wordObj.word || "", false);
      moveToP(curP, false);
      if(initStatus === "default"){
        setDefaultVisual();
      }else{
        applyContinuousVisual(curP);
      }
    });

    // resize: 위치 재정렬
    let rt = null;
    window.addEventListener("resize", ()=>{
      clearTimeout(rt);
      rt = setTimeout(()=>{
        const st = wordObj.status || "default";
        curP = statusToP(st);
        setPillTransformByP(curP);
      }, 80);
    }, { passive:true });

    return el;
  }

  let state = loadState();

  function render(){
    listEl.innerHTML = "";
    const count = state.words.length;

    const remain = Math.max(0, 3 - state.chargeUsed);
    remainText.textContent = `${remain}/3`;
    btnCharge.disabled = remain <= 0;

    if(count === 0){
      emptyState.style.display = "block";
      return;
    }
    emptyState.style.display = "none";

    for(const w of state.words){
      listEl.appendChild(buildTrackRow(w, state));
    }
  }

  // Charge modal
  btnCharge.addEventListener("click", ()=>{
    state = loadState();
    const remain = Math.max(0, 3 - state.chargeUsed);
    remainText.textContent = `${remain}/3`;
    dlgChargeDo.disabled = remain <= 0;
    dlgCharge.show();
  });
  dlgChargeClose.addEventListener("click", ()=> dlgCharge.hide());

  dlgChargeDo.addEventListener("click", ()=>{
    state = loadState();
    const remain = 3 - state.chargeUsed;
    if(remain <= 0){
      dlgCharge.hide();
      showToast("오늘 충전은 3회까지예요.");
      return;
    }
    state.words = state.words.concat(makeDummyWords(10));
    state.chargeUsed += 1;
    saveState(state);
    dlgCharge.hide();
    render();
    showToast(`충전 완료! +10개 (남은 ${Math.max(0, 3 - state.chargeUsed)}/3)`);
  });

  render();
  requestAnimationFrame(()=> document.documentElement.classList.add("ready"));
  </script>
</body>
</html>
