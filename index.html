<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>신호등보카 (Rebuild)</title>

  <!-- Shoelace (CDN) -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.15.0/cdn/themes/light.css">
  <script type="module" src="https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.15.0/cdn/shoelace.js"></script>

  <style>
    :root{
      --app-max: 520px;

      /* timings */
      --move-ms: 360ms;          /* pill 이동 */
      --peek-in-ms: 120ms;       /* word->meaning 페이드 */
      --peek-hold-ms: 560ms;     /* meaning 유지 */
      --peek-out-ms: 200ms;      /* meaning->word 페이드 */

      /* Theme */
      --bg0: #070a10;
      --bg1: #0b0f14;

      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.58);

      --track: rgba(255,255,255,.06);
      --line: rgba(255,255,255,.10);

      --radius: 18px;
      --pill-radius: 999px;

      --track-h: 72px;

      /* pill */
      --pill-h: 44px;
      --pill-minw: 140px;    /* ✅ min-width */
      --pill-pad-x: 14px;    /* pill 내부 좌우 padding */
      --pill-bd: 1px;

      --pad: 12px;
      --lr-pad: 12px;

      /* Lights */
      --red:   255, 90,  90;
      --green:  80, 220, 140;
      --amber: 255, 170,  70;

      /* default pill (처음) */
      --default-pill-alpha: .18;
      --default-pill-bd-alpha: .12;
    }

    *{ box-sizing:border-box; }
    html{ background: var(--bg0); }
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Apple SD Gothic Neo", "Noto Sans KR", Arial, "Helvetica Neue", sans-serif;
      color: var(--text);
      min-height: 100svh;
      background: transparent;
    }
    body::before{
      content:"";
      position: fixed;
      inset: 0;
      z-index: -1;
      pointer-events:none;
      background:
        radial-gradient(1200px 800px at 50% -200px, rgba(80,130,255,.18), transparent 60%),
        linear-gradient(180deg, var(--bg0), var(--bg1) 40%, var(--bg0));
      transform: translateZ(0);
    }

    sl-dialog:not(:defined){ display:none !important; }
    sl-alert:not(:defined){ display:none !important; }
    sl-button:not(:defined){ visibility:hidden; }

    .app{
      max-width: var(--app-max);
      margin: 0 auto;
      padding: 18px var(--pad) 120px;
    }

    /* Header */
    .header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 12px;
      margin: 6px 0 12px;
    }
    .header h1{
      margin: 0;
      font-size: 28px;
      letter-spacing: -.4px;
      font-weight: 900;
      line-height: 1.1;
    }

    /* toast */
    .toast-wrap{
      position: sticky;
      top: 10px;
      z-index: 999;
      padding: 0 var(--pad);
    }
    .toast-wrap sl-alert{
      max-width: var(--app-max);
      margin: 0 auto;
      border-radius: 14px;
    }

    /* ✅ 단 1번만 등장하는 고정 신호등(헤더 아래) */
    .lights-bar{
      position: relative;
      height: 36px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.03);
      overflow: hidden;
      display:flex;
      align-items:center;
      justify-content:center;
      gap: 18px;
      margin: 8px 0 12px;
    }
    .lights-bar::before{
      content:"";
      position:absolute;
      inset:0;
      pointer-events:none;
      background: radial-gradient(600px 120px at 50% 0%, rgba(255,255,255,.06), transparent 60%);
      opacity:.9;
    }
    .light-dot{
      position: relative;
      width: 14px;
      height: 14px;
      border-radius: 999px;
      opacity: .62;
      filter: saturate(1.05);
    }
    .light-dot::after{
      content:"";
      position:absolute;
      inset:-14px;
      border-radius: 999px;
      filter: blur(10px);
      opacity: .55;
      background: radial-gradient(circle, rgba(255,255,255,.35), transparent 60%);
      mix-blend-mode: screen;
    }
    .light-dot.red{ background: rgba(var(--red), .92); box-shadow: 0 0 22px rgba(var(--red), .26), 0 0 46px rgba(var(--red), .12); }
    .light-dot.amb{ background: rgba(var(--amber), .92); box-shadow: 0 0 22px rgba(var(--amber), .22), 0 0 46px rgba(var(--amber), .10); }
    .light-dot.grn{ background: rgba(var(--green), .92); box-shadow: 0 0 22px rgba(var(--green), .22), 0 0 46px rgba(var(--green), .10); }

    /* list */
    .list{
      display:flex;
      flex-direction:column;
      gap: 14px;
      margin-top: 8px;
    }

    .empty{
      margin-top: 18px;
      padding: 18px;
      border: 1px dashed rgba(255,255,255,.16);
      border-radius: 16px;
      color: var(--muted);
      text-align:center;
      line-height: 1.6;
    }
    .empty b{ color: var(--text); }

    /* Track */
    .track{
      position: relative;
      height: var(--track-h);
      border-radius: var(--radius);
      background: var(--track);
      border: 1px solid var(--line);
      overflow: hidden;
      -webkit-tap-highlight-color: transparent;
    }

    /* ✅ 틴트는 전체를 꽉 채우지 않고 "짧고 은은한" 라디얼 */
    .tint{
      position:absolute;
      inset:0;
      opacity: 0;
      pointer-events:none;
      transition: opacity .10s linear;
    }
    .tint.left{
      background: radial-gradient(520px 220px at 0% 55%, rgba(255,90,90,.22), transparent 66%);
    }
    .tint.right{
      background: radial-gradient(520px 220px at 100% 55%, rgba(80,220,140,.22), transparent 66%);
    }
    .tint.ambL{
      background: radial-gradient(420px 190px at 0% 55%, rgba(255,170,70,.12), transparent 70%);
    }
    .tint.ambR{
      background: radial-gradient(420px 190px at 100% 55%, rgba(255,170,70,.12), transparent 70%);
    }

    /* zones */
    .zone{
      position:absolute;
      top:0; bottom:0;
      z-index: 3;
      background: transparent;
    }
    .zone.left{ left:0; width:34%; }
    .zone.center{ left:33%; width:34%; }
    .zone.right{ right:0; width:34%; }

    /* Pill */
    .pill{
      position:absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) translateX(0px);
      height: var(--pill-h);
      min-width: var(--pill-minw);
      width: var(--pill-minw);

      border-radius: var(--pill-radius);
      display:flex;
      align-items:center;
      justify-content:center;

      padding: 0 var(--pill-pad-x);
      user-select:none;
      -webkit-user-select:none;
      touch-action: manipulation;
      cursor: pointer;

      /* default look (초기) */
      background: rgba(230,235,245,var(--default-pill-alpha));
      border: var(--pill-bd) solid rgba(255,255,255,var(--default-pill-bd-alpha));

      will-change: transform, width, background, border-color;
      transition:
        transform var(--move-ms) cubic-bezier(.2,.9,.25,1),
        width 220ms ease,
        background 120ms linear,
        border-color 120ms linear;

      z-index: 4;
      overflow: hidden;
    }

    .pill-text{
      display:block;
      width:100%;
      text-align:center;
      white-space: nowrap;   /* ✅ 줄바꿈 금지 */
      overflow: visible;     /* ✅ 자르기 금지 (pill이 늘어날 거라) */
      text-overflow: clip;   /* ✅ 말줄임 금지 */
      font-weight: 900;
      letter-spacing: -.2px;
      color: rgba(255,255,255,.92);
      font-size: 15px;
      transition: opacity 120ms ease;
    }
    .pill.is-meaning .pill-text{
      font-weight: 600;
      color: rgba(255,255,255,.78);
      font-size: 14px;
    }

    /* Footer (유지) */
    .footer{
      position: fixed;
      left:0; right:0; bottom:0;
      padding: 12px var(--pad) calc(12px + env(safe-area-inset-bottom));
      background: linear-gradient(180deg, transparent, rgba(0,0,0,.35) 25%, rgba(0,0,0,.55));
      backdrop-filter: blur(10px);
      z-index: 50;

      opacity: 0;
      transform: translateY(8px);
      pointer-events:none;
      transition: opacity .18s ease, transform .18s ease;
    }
    html.ready .footer{
      opacity: 1;
      transform: translateY(0);
      pointer-events:auto;
    }
    .footer-inner{
      max-width: var(--app-max);
      margin: 0 auto;
    }

    /* Shoelace tweaks */
    sl-dialog::part(panel){
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(20,24,32,.96);
      color: var(--text);
    }
    sl-dialog::part(title){
      font-weight: 900;
      letter-spacing: -.2px;
    }
    sl-button::part(base){ border-radius: 14px; }

    .charge-msg{
      font-size: 14px;
      color: rgba(255,255,255,.86);
      line-height: 1.5;
      margin-bottom: 10px;
    }
    .charge-remain{
      font-size: 12px;
      color: var(--muted);
      margin-bottom: 14px;
    }
    .btn-row{ display:flex; gap: 10px; }
    .btn-row sl-button{ flex: 1 1 0; }
    .btn-row sl-button::part(base){ width: 100%; }

    /* measurer */
    .measure{
      position:absolute;
      left:-9999px;
      top:-9999px;
      visibility:hidden;
      white-space:nowrap;
      letter-spacing:-.2px;
    }
  </style>
</head>

<body>
  <div class="toast-wrap" aria-live="polite" aria-atomic="true">
    <sl-alert id="toast" variant="primary" duration="2200" closable>
      <sl-icon slot="icon" name="info-circle"></sl-icon>
      <span id="toastText">안내</span>
    </sl-alert>
  </div>

  <main class="app">
    <div class="header">
      <h1>오늘의 단어</h1>
      <sl-button id="btnCharge" variant="primary">충전하기</sl-button>
    </div>

    <!-- ✅ 고정 신호등(트랙별이 아니라 1회만) -->
    <div class="lights-bar" aria-label="신호등">
      <span class="light-dot red" aria-hidden="true"></span>
      <span class="light-dot amb" aria-hidden="true"></span>
      <span class="light-dot grn" aria-hidden="true"></span>
    </div>

    <div id="emptyState" class="empty" style="display:none;">
      아직 오늘의 단어가 <b>0개</b>예요.<br>
      상단의 <b>충전하기</b>로 10개씩 추가해 주세요.
    </div>

    <div id="list" class="list"></div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      <sl-button id="ctaSubmit" variant="neutral" outline disabled style="width:100%;">제출하기 (Phase 2~)</sl-button>
    </div>
  </footer>

  <!-- Charge dialog -->
  <sl-dialog id="dlgCharge" label="충전하기">
    <div class="charge-msg">한 번에 10개씩 충전이 가능해요</div>
    <div class="charge-remain">오늘 남은 횟수 <b id="remainText">3/3</b></div>

    <div class="btn-row">
      <sl-button id="dlgChargeDo" variant="primary">충전하기</sl-button>
      <sl-button id="dlgChargeClose" variant="default" outline>닫기</sl-button>
    </div>
  </sl-dialog>

  <span id="measurer" class="measure"></span>

  <script>
  /* =========================================================
    Rebuild v0 (요구사항 기반)
    - 상태: default / red / yellow / green
    - default는 "어느 영역이든 한번 터치하면" 다시 돌아오지 않음
    - 슬라이드/드래그 제거 (클릭/터치로 이동)
    - 영역 터치: pill이 트랙 따라 스무스 이동 + meaning peek (word->meaning->word)
    - pill 클릭: 같은 meaning peek 재생
    - meaning은 말줄임/줄바꿈/자르기 금지 => pill width를 부드럽게 조절
    - 색상/틴트는 이동 중 연속 변화 유지, 틴트는 전체를 꽉 채우지 않음
    - 라이트(신호등)은 헤더 아래에 1번만 고정 표시
  ========================================================= */

  /* =========================
     Storage (optional)
  ========================= */
  const LS_KEY = "signal_vocab_rebuild_v0";
  const todayKey = (() => {
    const d = new Date();
    const y = d.getFullYear();
    const m = String(d.getMonth() + 1).padStart(2, "0");
    const day = String(d.getDate()).padStart(2, "0");
    return `${y}-${m}-${day}`;
  })();

  function loadState(){
    try{
      const raw = localStorage.getItem(LS_KEY);
      if(!raw) return { day: todayKey, chargeUsed: 0, words: [] };
      const s = JSON.parse(raw);
      if(s.day !== todayKey) return { day: todayKey, chargeUsed: 0, words: [] };
      return {
        day: s.day || todayKey,
        chargeUsed: Number(s.chargeUsed || 0),
        words: Array.isArray(s.words) ? s.words : []
      };
    }catch(e){
      return { day: todayKey, chargeUsed: 0, words: [] };
    }
  }
  function saveState(state){
    localStorage.setItem(LS_KEY, JSON.stringify(state));
  }

  /* =========================
     Dummy words
  ========================= */
  function makeDummyWords(n){
    const pool = [
      ["abandon", "버리다, 포기하다"],
      ["accurate", "정확한"],
      ["benevolent", "자비로운, 선의의"],
      ["consequence", "결과, 영향"],
      ["diligent", "성실한"],
      ["elaborate", "정교한, 상세히 설명하다"],
      ["friction", "마찰, 충돌"],
      ["gratitude", "감사"],
      ["hesitate", "망설이다"],
      ["inevitable", "피할 수 없는"]
    ];
    const out = [];
    const base = Date.now().toString(36);
    for(let i=0;i<n;i++){
      const pick = pool[Math.floor(Math.random()*pool.length)];
      out.push({
        id: `${base}-${i}-${Math.random().toString(16).slice(2,8)}`,
        word: pick[0],
        meaning: pick[1],
        status: "default",     // ✅ default/red/yellow/green
        touched: false         // ✅ 한번이라도 영역 터치하면 true
      });
    }
    return out;
  }

  /* =========================
     UI refs
  ========================= */
  const toast = document.getElementById("toast");
  const toastText = document.getElementById("toastText");
  function showToast(msg){
    toastText.textContent = msg;
    toast.toast();
  }

  const btnCharge = document.getElementById("btnCharge");
  const dlgCharge = document.getElementById("dlgCharge");
  const dlgChargeDo = document.getElementById("dlgChargeDo");
  const dlgChargeClose = document.getElementById("dlgChargeClose");
  const remainText = document.getElementById("remainText");

  const listEl = document.getElementById("list");
  const emptyState = document.getElementById("emptyState");
  const measurer = document.getElementById("measurer");

  function escapeHtml(s){
    return String(s)
      .replaceAll("&", "&amp;")
      .replaceAll("<", "&lt;")
      .replaceAll(">", "&gt;")
      .replaceAll('"', "&quot;")
      .replaceAll("'", "&#039;");
  }

  /* =========================
     Color helpers (continuous)
  ========================= */
  const RGB_RED   = [255, 90, 90];
  const RGB_AMBER = [255, 170, 70];
  const RGB_GREEN = [80, 220, 140];

  function clamp01(x){ return Math.max(0, Math.min(1, x)); }
  function lerp(a,b,t){ return a + (b-a)*t; }
  function easeInOutCubic(t){
    t = clamp01(t);
    return t < 0.5 ? 4*t*t*t : 1 - Math.pow(-2*t + 2, 3) / 2;
  }
  function mix3(p){
    // p: 0..1, red -> amber -> green
    let rgb;
    if(p <= 0.5){
      const t = p / 0.5;
      rgb = [
        Math.round(lerp(RGB_RED[0], RGB_AMBER[0], t)),
        Math.round(lerp(RGB_RED[1], RGB_AMBER[1], t)),
        Math.round(lerp(RGB_RED[2], RGB_AMBER[2], t))
      ];
    }else{
      const t = (p - 0.5) / 0.5;
      rgb = [
        Math.round(lerp(RGB_AMBER[0], RGB_GREEN[0], t)),
        Math.round(lerp(RGB_AMBER[1], RGB_GREEN[1], t)),
        Math.round(lerp(RGB_AMBER[2], RGB_GREEN[2], t))
      ];
    }
    return rgb;
  }

  /* =========================
     Text measure => pill width
     - 줄바꿈/말줄임/자르기 없이
     - 텍스트 길이에 맞춰 width를 부드럽게 조절
  ========================= */
  function measureTextPx(text, isMeaning){
    measurer.style.fontSize = isMeaning ? "14px" : "15px";
    measurer.style.fontWeight = isMeaning ? "600" : "900";
    measurer.textContent = text || "";
    return Math.ceil(measurer.getBoundingClientRect().width);
  }

  function setPillWidthToText(pillEl, text, isMeaning){
    const minW = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--pill-minw")) || 140;
    const padX = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--pill-pad-x")) || 14;
    const bd = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--pill-bd")) || 1;

    // 텍스트 폭 + 좌우 padding + border
    const tW = measureTextPx(text, isMeaning);
    const w = Math.max(minW, tW + (padX*2) + (bd*2) + 6);
    pillEl.style.width = w + "px";
  }

  /* =========================
     Track builder (동작 핵심)
  ========================= */
  function buildTrackRow(wordObj, state){
    const el = document.createElement("div");
    el.className = "track";
    el.dataset.id = wordObj.id;

    el.innerHTML = `
      <div class="tint left"></div>
      <div class="tint right"></div>
      <div class="tint ambL"></div>
      <div class="tint ambR"></div>

      <div class="zone left" aria-label="왼쪽(RED)"></div>
      <div class="zone center" aria-label="가운데(YELLOW)"></div>
      <div class="zone right" aria-label="오른쪽(GREEN)"></div>

      <div class="pill" role="button" aria-label="단어 필">
        <span class="pill-text">${escapeHtml(wordObj.word)}</span>
      </div>
    `;

    const tintL  = el.querySelector(".tint.left");
    const tintR  = el.querySelector(".tint.right");
    const tintAL = el.querySelector(".tint.ambL");
    const tintAR = el.querySelector(".tint.ambR");

    const zoneL  = el.querySelector(".zone.left");
    const zoneC  = el.querySelector(".zone.center");
    const zoneR  = el.querySelector(".zone.right");

    const pill   = el.querySelector(".pill");
    const txt    = el.querySelector(".pill-text");

    // 기본: word 기준으로 min-width 맞추기(단어가 길면 확장)
    setPillWidthToText(pill, wordObj.word || "", false);

    // 현재 위치/진행도
    let curP = 0.5; // default는 중앙에서 시작
    let targetP = 0.5;
    let moving = false;

    // peek 동시성 방지
    let peekToken = 0;
    let showingMeaning = false;

    function statusToP(status){
      if(status === "red") return 0;
      if(status === "green") return 1;
      if(status === "yellow") return 0.5;
      // default: center
      return 0.5;
    }

    function pToX(p){
      // track 내부에서 pill이 좌/중/우로 움직이도록 minX/maxX 계산
      const trackW = el.getBoundingClientRect().width;
      const pillW = pill.getBoundingClientRect().width;
      const pad = 10;
      const half = trackW/2;
      const halfP = pillW/2;
      const minX = -(half - halfP - pad);
      const maxX = +(half - halfP - pad);
      const x = lerp(minX, maxX, p);
      return { x, minX, maxX };
    }

    function applyContinuousVisual(p){
      // 1) pill 색상 연속 변화
      const rgb = mix3(p);
      const a = 0.30;
      const bdA = 0.32;
      pill.style.background = `rgba(${rgb[0]},${rgb[1]},${rgb[2]},${a})`;
      pill.style.borderColor = `rgba(${rgb[0]},${rgb[1]},${rgb[2]},${bdA})`;

      // 2) tint 연속 변화 (전체 채움 X : CSS radial gradient)
      const redI = clamp01((0.5 - p) / 0.5);      // 0.5->0 갈수록 1
      const greenI = clamp01((p - 0.5) / 0.5);    // 0.5->1 갈수록 1
      const yellowI = 1 - clamp01(Math.abs(p - 0.5) / 0.5); // center peak

      tintL.style.opacity  = String(Math.min(1, redI * 0.85));
      tintR.style.opacity  = String(Math.min(1, greenI * 0.85));
      tintAL.style.opacity = String(Math.min(1, yellowI * 0.55));
      tintAR.style.opacity = String(Math.min(1, yellowI * 0.55));
    }

    function setDefaultVisual(){
      // default: pill은 CSS 기본값(연한 회색)으로 복귀시키고, tint는 꺼둠
      pill.style.background = "";
      pill.style.borderColor = "";
      tintL.style.opacity = "0";
      tintR.style.opacity = "0";
      tintAL.style.opacity = "0";
      tintAR.style.opacity = "0";
    }

    function moveToP(nextP, animate){
      // 폭이 변할 수 있으니 이동 직전에 재계산
      const { x } = pToX(nextP);
      if(!animate){
        pill.style.transition = "none";
        pill.style.transform = `translate(-50%, -50%) translateX(${x}px)`;
        pill.offsetHeight; // force reflow
        pill.style.transition = "";
        curP = nextP;
        applyContinuousVisual(curP);
        return;
      }

      // CSS transform은 자동 tween이지만, 색/틴트는 requestAnimationFrame으로 연속 업데이트
      moving = true;
      targetP = nextP;

      const moveMs = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--move-ms")) || 360;
      const t0 = performance.now();
      const fromP = curP;
      const toP = nextP;

      function step(now){
        const t = clamp01((now - t0)/moveMs);
        const e = easeInOutCubic(t);
        const p = lerp(fromP, toP, e);

        // 위치
        const { x } = pToX(p);
        pill.style.transform = `translate(-50%, -50%) translateX(${x}px)`;

        // 색/틴트 연속
        applyContinuousVisual(p);

        if(t < 1){
          requestAnimationFrame(step);
        }else{
          curP = toP;
          moving = false;
          applyContinuousVisual(curP);
        }
      }
      requestAnimationFrame(step);
    }

    function commitStatus(nextStatus){
      // default -> (첫 터치) 이후 default 금지
      const idx = state.words.findIndex(w => w.id === wordObj.id);
      if(idx < 0) return;

      const prev = state.words[idx].status || "default";
      if(prev === "default"){
        state.words[idx].touched = true;
      }
      // default로는 못 돌아감(요구사항)
      if(state.words[idx].touched && nextStatus === "default"){
        nextStatus = "yellow";
      }

      state.words[idx].status = nextStatus;
      saveState(state);
    }

    function startPeek(){
      // ✅ 이동/연타 중에도 꼬이지 않게 토큰으로 관리
      const token = ++peekToken;

      const inMs   = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--peek-in-ms")) || 120;
      const holdMs = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--peek-hold-ms")) || 560;
      const outMs  = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--peek-out-ms")) || 200;

      const word = wordObj.word || "";
      const meaning = wordObj.meaning || "";

      // 1) word fade out
      showingMeaning = true;
      txt.style.opacity = "0";

      setTimeout(()=>{
        if(token !== peekToken) return;

        // 2) swap to meaning + widen pill
        pill.classList.add("is-meaning");
        txt.textContent = meaning;
        setPillWidthToText(pill, meaning, true);
        txt.style.opacity = "1";

        // 3) hold then back
        setTimeout(()=>{
          if(token !== peekToken) return;

          txt.style.opacity = "0";
          setTimeout(()=>{
            if(token !== peekToken) return;

            pill.classList.remove("is-meaning");
            txt.textContent = word;

            // word 기준으로 다시 width 조정
            setPillWidthToText(pill, word, false);

            txt.style.opacity = "1";
            showingMeaning = false;

            // width 바뀌면 X 재계산 필요 -> 현재 curP 유지 위치로 재정렬
            const { x } = pToX(curP);
            pill.style.transform = `translate(-50%, -50%) translateX(${x}px)`;
          }, outMs);

        }, holdMs);

      }, inMs);
    }

    function onZone(status){
      // ✅ 첫 터치 이후 default 금지
      if(wordObj.status === "default"){
        wordObj.touched = true;
      }
      wordObj.status = status;

      commitStatus(status);

      // default면 기본색, 그 외는 연속색 표시
      if(status === "default"){
        setDefaultVisual();
        moveToP(0.5, true);
      }else{
        const p = statusToP(status);
        moveToP(p, true);
      }

      // 의미 peek
      startPeek();
    }

    // pill 클릭: 다시 뜻 보였다가 사라짐 (상태 이동 없음)
    function onPill(){
      // default라도 peek는 가능(요구사항 5)
      // 단, default 상태라면 tint/색은 기본 유지
      if(wordObj.status === "default"){
        setDefaultVisual();
        const { x } = pToX(curP);
        pill.style.transform = `translate(-50%, -50%) translateX(${x}px)`;
      }else{
        applyContinuousVisual(curP);
      }
      startPeek();
    }

    // 이벤트
    zoneL.addEventListener("click", (e)=>{ e.stopPropagation(); onZone("red"); });
    zoneC.addEventListener("click", (e)=>{ e.stopPropagation(); onZone("yellow"); });
    zoneR.addEventListener("click", (e)=>{ e.stopPropagation(); onZone("green"); });
    pill.addEventListener("click", (e)=>{ e.stopPropagation(); onPill(); });

    // 초기 상태 적용
    const initStatus = wordObj.status || "default";
    curP = statusToP(initStatus);

    // 초기 배치: default는 기본, 나머지는 연속색+틴트
    requestAnimationFrame(()=>{
      if(initStatus === "default"){
        setDefaultVisual();
      }else{
        applyContinuousVisual(curP);
      }
      moveToP(curP, false);
    });

    // resize 시 위치 재정렬
    let rt = null;
    window.addEventListener("resize", ()=>{
      clearTimeout(rt);
      rt = setTimeout(()=>{
        const st = wordObj.status || "default";
        const p = statusToP(st);
        curP = p;
        // 폭이 바뀌면 위치 재계산
        const { x } = pToX(curP);
        pill.style.transform = `translate(-50%, -50%) translateX(${x}px)`;
      }, 80);
    }, { passive:true });

    return el;
  }

  /* =========================
     Render
  ========================= */
  let state = loadState();

  function render(){
    listEl.innerHTML = "";
    const count = state.words.length;

    // 충전 제한(기본 유지: 3회)
    const remain = Math.max(0, 3 - state.chargeUsed);
    remainText.textContent = `${remain}/3`;
    btnCharge.disabled = remain <= 0;

    if(count === 0){
      emptyState.style.display = "block";
      return;
    }
    emptyState.style.display = "none";

    for(const w of state.words){
      listEl.appendChild(buildTrackRow(w, state));
    }
  }

  /* =========================
     Charge modal (동작 유지)
  ========================= */
  btnCharge.addEventListener("click", ()=>{
    state = loadState();
    const remain = Math.max(0, 3 - state.chargeUsed);
    remainText.textContent = `${remain}/3`;
    dlgChargeDo.disabled = remain <= 0;
    dlgCharge.show();
  });

  dlgChargeClose.addEventListener("click", ()=> dlgCharge.hide());

  dlgChargeDo.addEventListener("click", ()=>{
    state = loadState();
    const remain = 3 - state.chargeUsed;
    if(remain <= 0){
      dlgCharge.hide();
      showToast("오늘 충전은 3회까지예요.");
      return;
    }
    state.words = state.words.concat(makeDummyWords(10));
    state.chargeUsed += 1;
    saveState(state);
    dlgCharge.hide();
    render();
    showToast(`충전 완료! +10개 (남은 ${Math.max(0, 3 - state.chargeUsed)}/3)`);
  });

  /* =========================
     Boot
  ========================= */
  // 첫 실행: 기본 0개로 시작(요구사항/이전 합의)
  // 단, 테스트 편의상 "처음 접속 시 0개"가 맞으면 그대로 두면 됨.
  // 필요하면 아래 주석 해제해서 첫 진입에 10개 자동 생성 가능.
  // if(state.words.length === 0){ state.words = makeDummyWords(10); saveState(state); }

  render();
  requestAnimationFrame(()=> document.documentElement.classList.add("ready"));
  </script>
</body>
</html>
