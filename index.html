<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>신호등보카 (Rebuild)</title>

  <!-- Shoelace (CDN) -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.15.0/cdn/themes/light.css">
  <script type="module" src="https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.15.0/cdn/shoelace.js"></script>

  <style>
    :root{
      --app-max: 520px;

      /* Layout */
      --pad: 12px;
      --lr-pad: 12px;
      --radius: 18px;
      --pill-radius: 999px;
      --track-h: 72px;
      --pill-h: 44px;
      --pill-minw: 140px;

      /* Timing */
      --move-ms: 360ms;
      --peek-in-ms: 90ms;
      --peek-hold-ms: 520ms;
      --peek-out-ms: 160ms;

      /* Theme */
      --bg0: #070a10;
      --bg1: #0b0f14;
      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.58);
      --track: rgba(255,255,255,.06);
      --line: rgba(255,255,255,.10);

      /* Lights RGB */
      --red:   255, 90,  90;
      --green:  80, 220, 140;
      --amber: 255, 170,  70;

      /* default pill */
      --pill-bg: rgba(230,235,245,.22);
      --pill-bd: rgba(255,255,255,.14);
    }

    *{ box-sizing: border-box; }
    html{ background: var(--bg0); }
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Apple SD Gothic Neo", "Noto Sans KR", Arial, "Helvetica Neue", sans-serif;
      color: var(--text);
      min-height: 100svh;
      background: transparent;
    }
    body::before{
      content:"";
      position: fixed;
      inset: 0;
      z-index: -1;
      pointer-events: none;
      background:
        radial-gradient(1200px 800px at 50% -200px, rgba(80,130,255,.18), transparent 60%),
        linear-gradient(180deg, var(--bg0), var(--bg1) 40%, var(--bg0));
      transform: translateZ(0);
    }

    sl-dialog:not(:defined){ display:none !important; }
    sl-alert:not(:defined){ display:none !important; }
    sl-button:not(:defined){ visibility:hidden; }

    .app{
      max-width: var(--app-max);
      margin: 0 auto;
      padding: 18px var(--pad) 120px;
    }

    .header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 12px;
      margin: 6px 0 12px;
    }
    .header h1{
      margin: 0;
      font-size: 28px;
      letter-spacing: -.4px;
      font-weight: 900;
      line-height: 1.1;
    }

    .toast-wrap{
      position: sticky;
      top: 10px;
      z-index: 999;
      padding: 0 var(--pad);
    }
    .toast-wrap sl-alert{
      max-width: var(--app-max);
      margin: 0 auto;
      border-radius: 14px;
    }

    /* One-time fixed lights (under header) */
    .lights-bar{
      display:flex;
      align-items:center;
      justify-content:center;
      gap: 10px;
      margin: 4px 0 14px;
      padding: 10px 0 2px;
    }
    .lights-bar .dot{
      width: 12px; height: 12px;
      border-radius: 999px;
      opacity: .85;
      box-shadow:
        0 0 18px rgba(255,255,255,.10);
      position: relative;
    }
    .lights-bar .dot::after{
      content:"";
      position:absolute;
      inset:-12px;
      border-radius: 999px;
      filter: blur(10px);
      opacity: .55;
      mix-blend-mode: screen;
      background: radial-gradient(circle, rgba(255,255,255,.35), transparent 60%);
    }
    .dot.red   { background: rgba(var(--red), .92);   box-shadow: 0 0 22px rgba(var(--red), .28), 0 0 42px rgba(var(--red), .14); }
    .dot.amber { background: rgba(var(--amber), .92); box-shadow: 0 0 22px rgba(var(--amber), .22), 0 0 42px rgba(var(--amber), .12); }
    .dot.green { background: rgba(var(--green), .92); box-shadow: 0 0 22px rgba(var(--green), .26), 0 0 42px rgba(var(--green), .14); }

    .list{
      display:flex;
      flex-direction:column;
      gap: 14px;
      margin-top: 12px;
    }

    .empty{
      margin-top: 18px;
      padding: 18px;
      border: 1px dashed rgba(255,255,255,.16);
      border-radius: 16px;
      color: var(--muted);
      text-align:center;
      line-height: 1.6;
    }
    .empty b{ color: var(--text); }

    /* Track */
    .track{
      position: relative;
      height: var(--track-h);
      border-radius: var(--radius);
      background: var(--track);
      border: 1px solid var(--line);
      overflow: hidden;
      -webkit-tap-highlight-color: transparent;
    }

    /* Tints (NOT full fill; short ambiance) */
    .tint{
      position:absolute;
      inset:0;
      opacity: 0;
      pointer-events:none;
    }
    .tint.left{
      background: radial-gradient(520px 220px at 0% 55%, rgba(255,90,90,.22), transparent 66%);
    }
    .tint.right{
      background: radial-gradient(520px 220px at 100% 55%, rgba(80,220,140,.22), transparent 66%);
    }
    .tint.amberL{
      background: radial-gradient(460px 200px at 0% 55%, rgba(255,170,70,.12), transparent 70%);
    }
    .tint.amberR{
      background: radial-gradient(460px 200px at 100% 55%, rgba(255,170,70,.12), transparent 70%);
    }

    /* Click zones */
    .zone{
      position:absolute;
      top:0; bottom:0;
      z-index: 3;
      background: transparent;
      cursor: pointer;
    }
    .zone.left{ left:0; width:34%; }
    .zone.center{ left:33%; width:34%; }
    .zone.right{ right:0; width:34%; }

    /* Pill */
    .pill{
      position:absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) translateX(0px);
      height: var(--pill-h);
      min-width: var(--pill-minw);
      width: var(--pill-minw);
      border-radius: var(--pill-radius);

      background: var(--pill-bg);
      border: 1px solid var(--pill-bd);

      display:flex;
      align-items:center;
      justify-content:center;
      padding: 0 14px;

      user-select:none;
      -webkit-user-select:none;
      touch-action: pan-y;

      /* width는 부드럽게, transform은 JS가 프레임별 제어(연속 tint/색상) */
      transition: width .22s ease, opacity .12s ease;
      will-change: transform, width, background, border-color;
      z-index: 4;

      overflow: visible; /* 텍스트는 잘리지 않게 */
    }

    .pill-text{
      display:block;
      width: 100%;
      text-align:center;

      /* 절대 말줄임/줄바꿈/자르기 금지 */
      white-space: nowrap;
      overflow: visible;
      text-overflow: clip;

      font-weight: 900;
      letter-spacing: -.2px;
      color: rgba(255,255,255,.92);
      font-size: 15px;

      transition: opacity .12s ease;
      pointer-events:none;
    }

    /* meaning style */
    .pill.is-meaning .pill-text{
      font-weight: 600;
      color: rgba(255,255,255,.78);
      font-size: 14px;
    }

    /* Footer */
    .footer{
      position: fixed;
      left:0; right:0; bottom:0;
      padding: 12px var(--pad) calc(12px + env(safe-area-inset-bottom));
      background: linear-gradient(180deg, transparent, rgba(0,0,0,.35) 25%, rgba(0,0,0,.55));
      backdrop-filter: blur(10px);
      z-index: 50;

      opacity: 0;
      transform: translateY(8px);
      pointer-events:none;
      transition: opacity .18s ease, transform .18s ease;
    }
    html.ready .footer{
      opacity: 1;
      transform: translateY(0);
      pointer-events:auto;
    }
    .footer-inner{
      max-width: var(--app-max);
      margin: 0 auto;
    }

    /* Shoelace tweaks */
    sl-dialog::part(panel){
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(20,24,32,.96);
      color: var(--text);
    }
    sl-dialog::part(title){
      font-weight: 900;
      letter-spacing: -.2px;
    }
    sl-button::part(base){ border-radius: 14px; }

    .charge-msg{
      font-size: 14px;
      color: rgba(255,255,255,.86);
      line-height: 1.5;
      margin-bottom: 10px;
    }
    .charge-remain{
      font-size: 12px;
      color: var(--muted);
      margin-bottom: 14px;
    }
    .btn-row{ display:flex; gap: 10px; }
    .btn-row sl-button{ flex: 1 1 0; }
    .btn-row sl-button::part(base){ width: 100%; }

    /* hidden measurer */
    .measure{
      position: absolute;
      left: -9999px;
      top: -9999px;
      visibility: hidden;
      white-space: nowrap;
      font-size: 14px;
      font-weight: 600;
      letter-spacing: -.2px;
    }
  </style>
</head>

<body>
  <div class="toast-wrap" aria-live="polite" aria-atomic="true">
    <sl-alert id="toast" variant="primary" duration="2200" closable>
      <sl-icon slot="icon" name="info-circle"></sl-icon>
      <span id="toastText">안내</span>
    </sl-alert>
  </div>

  <main class="app">
    <div class="header">
      <h1>오늘의 단어</h1>
      <sl-button id="btnCharge" variant="primary">충전하기</sl-button>
    </div>

    <!-- ✅ 라이트는 여기서 한 번만 고정 표시 -->
    <div class="lights-bar" aria-hidden="true">
      <div class="dot red"></div>
      <div class="dot amber"></div>
      <div class="dot green"></div>
    </div>

    <div id="emptyState" class="empty" style="display:none;">
      아직 오늘의 단어가 <b>0개</b>예요.<br>
      상단의 <b>충전하기</b>로 10개씩 추가해 주세요.
    </div>

    <div id="list" class="list"></div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      <sl-button id="ctaSubmit" variant="neutral" outline disabled style="width:100%;">제출하기 (Phase 2~)</sl-button>
    </div>
  </footer>

  <!-- Charge dialog -->
  <sl-dialog id="dlgCharge" label="충전하기">
    <div class="charge-msg">한 번에 10개씩 충전이 가능해요</div>
    <div class="charge-remain">오늘 남은 횟수 <b id="remainText">3/3</b></div>

    <div class="btn-row">
      <sl-button id="dlgChargeDo" variant="primary">충전하기</sl-button>
      <sl-button id="dlgChargeClose" variant="default" outline>닫기</sl-button>
    </div>
  </sl-dialog>

  <span id="measurer" class="measure"></span>

  <script>
  /* =========================================================
    Signal Vocab - Rebuild (Zones only + width anchor correction)
    - default -> first touch => red/yellow/green, no return to default
    - zone tap: move + show meaning (word->meaning->word)
    - NO pill click handler
    - continuous tint + pill color during move
    - width change anchor fix by ΔW/2 (red/green)
  ========================================================= */

  /* =========================
     Storage / State
  ========================= */
  const LS_KEY = "signal_vocab_rebuild_v1";
  const todayKey = (() => {
    const d = new Date();
    const y = d.getFullYear();
    const m = String(d.getMonth() + 1).padStart(2, "0");
    const day = String(d.getDate()).padStart(2, "0");
    return `${y}-${m}-${day}`;
  })();

  function loadState() {
    try {
      const raw = localStorage.getItem(LS_KEY);
      if (!raw) return { day: todayKey, chargeUsed: 0, words: [] };
      const s = JSON.parse(raw);
      if (s.day !== todayKey) return { day: todayKey, chargeUsed: 0, words: [] };
      return {
        day: s.day || todayKey,
        chargeUsed: Number(s.chargeUsed || 0),
        words: Array.isArray(s.words) ? s.words : []
      };
    } catch (e) {
      return { day: todayKey, chargeUsed: 0, words: [] };
    }
  }
  function saveState(state) {
    localStorage.setItem(LS_KEY, JSON.stringify(state));
  }

  function makeDummyWords(n) {
    const pool = [
      ["abandonddd", "버리다, 포기하다dddddddd"],
      ["accuratedddddddddd", "정확한"],
      ["benevolent", "자비로운, 선의의"],
      ["consequence", "결과, 영향"],
      ["diligent", "성실한"],
      ["elaborate", "정교한, 상세히 설명하다, ㅇㄹㅇㄹㅇㄹㅇㄹㅇ"],
      ["friction", "마찰, 충돌"],
      ["gratitude", "감사"],
      ["hesitate", "망설이다"],
      ["inevitable", "피할 수 없는"]
    ];
    const out = [];
    const base = Date.now().toString(36);
    for (let i = 0; i < n; i++) {
      const pick = pool[Math.floor(Math.random() * pool.length)];
      out.push({
        id: `${base}-${i}-${Math.random().toString(16).slice(2, 8)}`,
        word: pick[0],
        meaning: pick[1],
        status: "default" // default | red | yellow | green
      });
    }
    return out;
  }

  /* =========================
     UI refs
  ========================= */
  const toast = document.getElementById("toast");
  const toastText = document.getElementById("toastText");

  const btnCharge = document.getElementById("btnCharge");
  const dlgCharge = document.getElementById("dlgCharge");
  const dlgChargeDo = document.getElementById("dlgChargeDo");
  const dlgChargeClose = document.getElementById("dlgChargeClose");
  const remainText = document.getElementById("remainText");

  const listEl = document.getElementById("list");
  const emptyState = document.getElementById("emptyState");
  const measurer = document.getElementById("measurer");

  function showToast(msg) {
    toastText.textContent = msg;
    toast.toast();
  }

  function escapeHtml(s) {
    return String(s)
      .replaceAll("&", "&amp;")
      .replaceAll("<", "&lt;")
      .replaceAll(">", "&gt;")
      .replaceAll('"', "&quot;")
      .replaceAll("'", "&#039;");
  }

  /* =========================
     Motion / color helpers
  ========================= */
  function clamp01(x){ return Math.max(0, Math.min(1, x)); }
  function lerp(a,b,t){ return a + (b-a)*t; }
  function easeInOutCubic(t){
    t = clamp01(t);
    return t < 0.5 ? 4*t*t*t : 1 - Math.pow(-2*t + 2, 3) / 2;
  }
  function getVarMs(name, fallback){
    const v = getComputedStyle(document.documentElement).getPropertyValue(name).trim();
    if(!v) return fallback;
    if(v.endsWith("ms")) return parseFloat(v);
    if(v.endsWith("s")) return parseFloat(v) * 1000;
    const n = parseFloat(v);
    return Number.isFinite(n) ? n : fallback;
  }

  const RGB_RED   = [255, 90, 90];
  const RGB_GREEN = [80, 220, 140];
  const RGB_AMBER = [255, 170, 70];

  function setPillColorByProgress(p, pill){
    // 3-stop mix: red <-> amber <-> green
    let rgb, a = 0.30, bdA = 0.32;
    if(p <= 0.5){
      const t = p / 0.5;
      rgb = [
        Math.round(lerp(RGB_RED[0], RGB_AMBER[0], t)),
        Math.round(lerp(RGB_RED[1], RGB_AMBER[1], t)),
        Math.round(lerp(RGB_RED[2], RGB_AMBER[2], t)),
      ];
    }else{
      const t = (p - 0.5) / 0.5;
      rgb = [
        Math.round(lerp(RGB_AMBER[0], RGB_GREEN[0], t)),
        Math.round(lerp(RGB_AMBER[1], RGB_GREEN[1], t)),
        Math.round(lerp(RGB_AMBER[2], RGB_GREEN[2], t)),
      ];
    }
    pill.style.background = `rgba(${rgb[0]},${rgb[1]},${rgb[2]},${a})`;
    pill.style.borderColor = `rgba(${rgb[0]},${rgb[1]},${rgb[2]},${bdA})`;
  }

  function setTintsByProgress(p, tintL, tintR, tintAL, tintAR){
    // NOT full fill: just ambiance. Keep subtle.
    const redI = clamp01(1 - (p / 0.5));           // high at left
    const greenI = clamp01((p - 0.5) / 0.5);       // high at right
    const yellowI = clamp01(1 - Math.abs(p - 0.5) / 0.5); // peak at center

    tintL.style.opacity  = String(redI * 0.90);
    tintR.style.opacity  = String(greenI * 0.90);
    tintAL.style.opacity = String(yellowI * 0.55);
    tintAR.style.opacity = String(yellowI * 0.55);
  }

  /* =========================
     Measure / target width
     - no ellipsis / no wrap / no clip
     - width = max(min, measured + padding)
  ========================= */
  function measureTextPx(text, isMeaning){
    measurer.style.fontSize = isMeaning ? "14px" : "15px";
    measurer.style.fontWeight = isMeaning ? "600" : "900";
    measurer.style.letterSpacing = "-.2px";
    measurer.textContent = text || "";
    return measurer.getBoundingClientRect().width;
  }

  function computeTargetWidth(trackW, text, isMeaning){
    const minW = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--pill-minw")) || 140;

    // pill 내부 padding(좌우 14*2) + border 여유
    const innerPad = 28 + 18; // 안전 여유 포함
    const textW = measureTextPx(text, isMeaning);
    const want = Math.ceil(textW + innerPad);

    // track 안에서 너무 커지지 않게 상한(좌우 여백 20)
    const maxW = Math.max(minW, trackW - 20);
    return Math.min(maxW, Math.max(minW, want));
  }

  /* =========================
     Track builder / controller
  ========================= */
  function buildTrackRow(wordObj, index, state){
    const track = document.createElement("div");
    track.className = "track";
    track.dataset.index = String(index);

    track.innerHTML = `
      <div class="tint left"></div>
      <div class="tint right"></div>
      <div class="tint amberL"></div>
      <div class="tint amberR"></div>

      <div class="zone left" aria-label="왼쪽(RED)"></div>
      <div class="zone center" aria-label="가운데(YELLOW)"></div>
      <div class="zone right" aria-label="오른쪽(GREEN)"></div>

      <div class="pill" aria-hidden="true">
        <span class="pill-text">${escapeHtml(wordObj.word)}</span>
      </div>
    `;

    const tintL  = track.querySelector(".tint.left");
    const tintR  = track.querySelector(".tint.right");
    const tintAL = track.querySelector(".tint.amberL");
    const tintAR = track.querySelector(".tint.amberR");

    const zoneL = track.querySelector(".zone.left");
    const zoneC = track.querySelector(".zone.center");
    const zoneR = track.querySelector(".zone.right");

    const pill = track.querySelector(".pill");
    const pillTxt = track.querySelector(".pill-text");

    // Controller state
    let status = wordObj.status || "default"; // default/red/yellow/green
    let mode = "word"; // "word" | "meaning"
    let curX = 0;      // translateX px (relative to center)
    let anim = null;   // current move animation
    let token = 0;     // cancels pending peek timelines

    function getTrackW(){
      return track.getBoundingClientRect().width || 320;
    }

    // anchor positions (based on current width)
    function centerXForStatus(st, curWidth){
      const trackW = getTrackW();
      const edgePad = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--lr-pad")) || 12;
      const half = trackW / 2;

      if(st === "red"){
        // left edge fixed at edgePad
        return (edgePad + curWidth/2) - half;
      }
      if(st === "green"){
        // right edge fixed at trackW - edgePad
        return (trackW - edgePad - curWidth/2) - half;
      }
      // yellow or default: center
      return 0;
    }

    // progress mapping (based on current width so color stays consistent)
    function progress01FromX(x, curWidth){
      const minX = centerXForStatus("red", curWidth);
      const maxX = centerXForStatus("green", curWidth);
      if(maxX === minX) return 0.5;
      return clamp01((x - minX) / (maxX - minX));
    }

    function applyTransform(){
      pill.style.transform = `translate(-50%, -50%) translateX(${curX}px)`;
    }

    function setDefaultVisual(){
      // default: neutral pill, no tints
      pill.style.background = "";
      pill.style.borderColor = "";
      tintL.style.opacity = "0";
      tintR.style.opacity = "0";
      tintAL.style.opacity = "0";
      tintAR.style.opacity = "0";
      applyTransform();
    }

    function applyContinuousVisual(){
      const curW = parseFloat(getComputedStyle(pill).width) || 140;
      const p = progress01FromX(curX, curW);
      setPillColorByProgress(p, pill);
      setTintsByProgress(p, tintL, tintR, tintAL, tintAR);
    }

    function stopMoveAnim(){
      anim = null;
    }

    function animateMoveTo(targetX){
      const moveMs = getVarMs("--move-ms", 360);
      const fromX = curX;
      const toX = targetX;

      stopMoveAnim();
      const t0 = performance.now();

      anim = { fromX, toX, t0, dur: moveMs };

      function step(now){
        if(!anim) return;
        const t = clamp01((now - anim.t0) / anim.dur);
        const e = easeInOutCubic(t);
        curX = lerp(anim.fromX, anim.toX, e);

        applyTransform();
        // default는 색/틴트 없음
        if(status === "default"){
          // keep neutral
        }else{
          applyContinuousVisual();
        }

        if(t < 1){
          requestAnimationFrame(step);
        }else{
          anim = null;
        }
      }
      requestAnimationFrame(step);
    }

    // width anchor correction (ΔW/2)
    function applyWidthWithAnchor(nextW){
      const prevW = parseFloat(getComputedStyle(pill).width) || nextW;

      // width set + x correction must happen in same tick to avoid drift
      const dW = nextW - prevW;
      if(status === "red"){
        curX += dW / 2;        // keep left edge fixed
        if(anim) anim.toX += dW / 2; // keep move target consistent during motion
      }else if(status === "green"){
        curX -= dW / 2;        // keep right edge fixed
        if(anim) anim.toX -= dW / 2;
      }
      // yellow/default: no correction

      pill.style.width = `${nextW}px`;
      applyTransform();
    }

    function setMode(nextMode){
      mode = nextMode;
      if(mode === "meaning"){
        pill.classList.add("is-meaning");
      }else{
        pill.classList.remove("is-meaning");
      }
    }

    function cancelPeekNow(){
      token++;
      // reset text to word (safe)
      setMode("word");
      pillTxt.style.opacity = "1";
      pillTxt.textContent = wordObj.word || "";
      // reset width to word target
      const w = computeTargetWidth(getTrackW(), pillTxt.textContent, false);
      pill.style.width = `${w}px`;
      // visuals
      if(status === "default") setDefaultVisual();
      else applyContinuousVisual();
    }

    function playMeaningPeek(){
      // zone click always triggers this (even if same status)
      const my = ++token;

      const inMs   = getVarMs("--peek-in-ms", 90);
      const holdMs = getVarMs("--peek-hold-ms", 520);
      const outMs  = getVarMs("--peek-out-ms", 160);

      const trackW = getTrackW();

      // word target width (current)
      const wordText = wordObj.word || "";
      const meanText = wordObj.meaning || "";

      const wordW = computeTargetWidth(trackW, wordText, false);
      const meanW = computeTargetWidth(trackW, meanText, true);

      // Ensure we're in word baseline first
      setMode("word");
      pillTxt.textContent = wordText;
      pillTxt.style.opacity = "1";
      applyWidthWithAnchor(wordW);

      // fade out word
      pillTxt.style.opacity = "0";

      setTimeout(()=>{
        if(my !== token) return;

        // swap to meaning + width change (anchor-correct)
        setMode("meaning");
        pillTxt.textContent = meanText;
        applyWidthWithAnchor(meanW);
        pillTxt.style.opacity = "1";

        // hold
        setTimeout(()=>{
          if(my !== token) return;

          // fade out meaning
          pillTxt.style.opacity = "0";

          setTimeout(()=>{
            if(my !== token) return;

            // back to word + width restore (anchor-correct)
            setMode("word");
            pillTxt.textContent = wordText;
            applyWidthWithAnchor(wordW);
            pillTxt.style.opacity = "1";

          }, outMs);

        }, holdMs);

      }, inMs);
    }

    function applyStatus(nextStatus){
      // default는 첫 터치 이후 절대 복귀 불가
      if(status !== "default" && nextStatus === "default"){
        nextStatus = "yellow";
      }
      if(status === "default" && nextStatus === "default"){
        nextStatus = "yellow";
      }

      // 상태 저장
      status = nextStatus;
      wordObj.status = nextStatus;
      state.words[index].status = nextStatus;
      saveState(state);

      // 기존 타임라인 정리(잔상 방지)
      cancelPeekNow();

      // move target (based on current word width)
      const curW = parseFloat(getComputedStyle(pill).width) || 140;
      const targetX = centerXForStatus(status === "default" ? "yellow" : status, curW);

      if(status === "default"){
        curX = 0;
        setDefaultVisual();
      }else{
        animateMoveTo(targetX);
        // peek starts immediately (요구사항: 영역 터치하면 의미 표시)
        playMeaningPeek();
      }
    }

    // zones only (NO pill click)
    zoneL.addEventListener("click", ()=> applyStatus(status === "default" ? "red" : "red"));
    zoneC.addEventListener("click", ()=> applyStatus(status === "default" ? "yellow" : "yellow"));
    zoneR.addEventListener("click", ()=> applyStatus(status === "default" ? "green" : "green"));

    // init visuals
    (function init(){
      // baseline text/width
      pillTxt.textContent = wordObj.word || "";
      const w = computeTargetWidth(getTrackW(), pillTxt.textContent, false);
      pill.style.width = `${w}px`;

      // start x at status position
      const st = status;
      if(st === "default"){
        curX = 0;
        setDefaultVisual();
      }else{
        curX = centerXForStatus(st, w);
        applyTransform();
        applyContinuousVisual();
      }
    })();

    // resize handling: keep anchor consistent
    let resizeT = null;
    window.addEventListener("resize", ()=>{
      clearTimeout(resizeT);
      resizeT = setTimeout(()=>{
        // On resize: recompute width targets for current mode/text
        const trackW = getTrackW();
        const isMeaning = (mode === "meaning");
        const text = isMeaning ? (wordObj.meaning||"") : (wordObj.word||"");
        const targetW = computeTargetWidth(trackW, text, isMeaning);

        // apply width with anchor correction (safe)
        applyWidthWithAnchor(targetW);

        // recompute position "absolute anchor" for current status
        // (use current width, but DO NOT jump: animate a tiny correction)
        if(status !== "default"){
          const curW = parseFloat(getComputedStyle(pill).width) || targetW;
          const wantX = centerXForStatus(status, curW);
          animateMoveTo(wantX);
        }else{
          curX = 0;
          setDefaultVisual();
        }
      }, 120);
    }, { passive:true });

    return track;
  }

  /* =========================
     Render
  ========================= */
  let state = loadState();

  function render(){
    listEl.innerHTML = "";
    const count = state.words.length;

    const remain = Math.max(0, 3 - state.chargeUsed);
    remainText.textContent = `${remain}/3`;
    btnCharge.disabled = remain <= 0;

    if(count === 0){
      emptyState.style.display = "block";
      return;
    }
    emptyState.style.display = "none";

    state.words.forEach((w, idx)=>{
      listEl.appendChild(buildTrackRow(w, idx, state));
    });
  }

  /* =========================
     Charge modal
  ========================= */
  btnCharge.addEventListener("click", () => {
    state = loadState();
    const remain = Math.max(0, 3 - state.chargeUsed);
    remainText.textContent = `${remain}/3`;
    dlgChargeDo.disabled = remain <= 0;
    dlgCharge.show();
  });

  dlgChargeClose.addEventListener("click", () => dlgCharge.hide());

  dlgChargeDo.addEventListener("click", () => {
    state = loadState();
    const remain = 3 - state.chargeUsed;
    if(remain <= 0){
      dlgCharge.hide();
      showToast("오늘 충전은 3회까지예요.");
      return;
    }
    state.words = state.words.concat(makeDummyWords(10));
    state.chargeUsed += 1;
    saveState(state);
    dlgCharge.hide();

    render();
    showToast(`충전 완료! +10개 (남은 ${Math.max(0, 3 - state.chargeUsed)}/3)`);
  });

  /* =========================
     Boot
  ========================= */
  render();
  requestAnimationFrame(() => document.documentElement.classList.add("ready"));
  </script>
</body>
</html>
